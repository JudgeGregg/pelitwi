<!DOCTYPE html>
<html lang="en">
<head>
          <title>Test Pelican - Getting Connected with Endpoints</title>
        <meta charset="utf-8" />
        <meta name="generator" content="Pelican" />

        <meta name="Description" content="An event-driven networking engine written in Python and MIT licensed." />

        <link rel="stylesheet" type="text/css" href="https://judgegregg.github.io/pelitwi/theme/css/twistedtrac.css" />


</head>

<body>
        <div id="banner">
                <div id="top_grad"></div>
                <div id="tab">
                        <a href="https://twistedmatrix.com/trac/wiki">HOME</a>
                        <a href="https://twistedmatrix.com/trac/wiki/FrequentlyAskedQuestions">FAQ</a>
                        <a href="/">DOCS</a>
                        <a href="https://twistedmatrix.com/trac/wiki/Downloads">DOWNLOAD</a>
                </div>

                <div id="header">
                        <a id="logo" href="https://judgegregg.github.io/pelitwi/"><img src="https://judgegregg.github.io/pelitwi/theme/images/trac_banner.png" alt="Twisted" /></a>
                </div>
        </div>

<div id="mainnav" class="related">
	<ul>
		<li><a href="https://judgegregg.github.io/pelitwi">Twisted 21.2.0 documentation</a> Â»</li>
	</ul>
</div>
        <div id="ctxtnav" class="nav">
        </div>

    <section>

    <div class="document">
        <div class="documentwrapper">
        <div class="bodywrapper">
        <h1>Getting Connected with Endpoints</h1>
        
        <div class="entry-content">
        <div class="section" id="introduction">
<h2><a class="toc-backref" href="#id1">Introduction</a></h2>
<p>On a network, one can think of any given connection as a long wire, stretched between two points.
Lots of stuff can happen along the length of that wire - routers, switches, network address translation, and so on, but that is usually invisible to the application passing data across it.
Twisted strives to make the nature of the "wire" as transparent as possible, with highly abstract interfaces for passing and receiving data, such as <cite>ITransport &lt;twisted.internet.interfaces.ITransport&gt;</cite> and <cite>IProtocol &lt;twisted.internet.interfaces.IProtocol&gt;</cite>.</p>
<p>However, the application can't be completely ignorant of the wire.
In particular, it must do something to <em>start</em> the connection, and
to do so, it must identify the <em>end points</em> of the wire. There are
different names for the roles of each end point - "initiator" and
"responder", "connector" and "listener", or "client" and "server" - but the
common theme is that one side of the connection waits around for someone to
connect to it, and the other side does the connecting.</p>
<p>In Twisted 10.1, several new interfaces were introduced to describe each of these roles for stream-oriented connections: <cite>IStreamServerEndpoint &lt;twisted.internet.interfaces.IStreamServerEndpoint&gt;</cite> and <cite>IStreamClientEndpoint &lt;twisted.internet.interfaces.IStreamClientEndpoint&gt;</cite>.
The word "stream", in this case, refers to endpoints which treat a connection as a continuous stream of bytes, rather than a sequence of discrete datagrams:
TCP is a "stream" protocol whereas UDP is a "datagram" protocol.</p>
</div>
<div class="section" id="constructing-and-using-endpoints">
<h2><a class="toc-backref" href="#id2">Constructing and Using Endpoints</a></h2>
<p>In both <a class="reference external" href="https://judgegregg.github.io/pelitwi/pages/writing-servers.html">Writing Servers</a> and <cite>Writing Clients &lt;clients&gt;</cite>, we covered basic usage of endpoints;
you construct an appropriate type of server or client endpoint, and then call <tt class="docutils literal">listen</tt> (for servers) or <tt class="docutils literal">connect</tt> (for clients).</p>
<p>In both of those tutorials, we constructed specific types of endpoints directly.
However, in most programs, you will want to allow the user to specify where to listen or connect, in a way which will allow the user to request different strategies, without having to adjust your program.
In order to allow this, you should use <cite>clientFromString &lt;twisted.internet.endpoints.clientFromString&gt;</cite> or <cite>serverFromString &lt;twisted.internet.endpoints.serverFromString&gt;</cite>.</p>
<div class="section" id="there-s-not-much-to-it">
<h3><a class="toc-backref" href="#id3">There's Not Much To It</a></h3>
<p>Each type of endpoint is just an interface with a single method that
takes an argument. <tt class="docutils literal">serverEndpoint.listen(factory)</tt> will start
listening on that endpoint with your protocol factory, and <tt class="docutils literal">clientEndpoint.connect(factory)</tt> will start a single connection
attempt. Each of these APIs returns a value, though, which can be important.</p>
<p>However, if you are not already, you <em>should</em> be very familiar with <a class="reference external" href="https://judgegregg.github.io/pelitwi/pages/deferred-reference.html">Deferreds</a>, as they are returned by both <tt class="docutils literal">connect</tt> and <tt class="docutils literal">listen</tt> methods, to indicate when the connection has connected or the listening port is up and running.</p>
</div>
<div class="section" id="servers-and-stopping">
<h3><a class="toc-backref" href="#id4">Servers and Stopping</a></h3>
<p><cite>IStreamServerEndpoint.listen &lt;twisted.internet.interfaces.IStreamServerEndpoint.listen&gt;</cite> returns a <cite>Deferred &lt;twisted.internet.defer.Deferred&gt;</cite> that fires with an <cite>IListeningPort &lt;twisted.internet.interfaces.IListeningPort&gt;</cite>.
Note that this deferred may errback.
The most common cause of such an error would be that another program is already using the requested port number, but the exact cause may vary depending on what type of endpoint you are listening on.
If you receive such an error, it means that your application is not actually listening, and will not receive any incoming connections.
It's important to somehow alert an administrator of your server, in this case, especially if you only have one listening port!</p>
<p>Note also that once this has succeeded, it will continue listening forever.
If you need to <em>stop</em> listening for some reason, in response to anything other than a full server shutdown (<tt class="docutils literal">reactor.stop</tt> and / or <tt class="docutils literal">twistd</tt> will usually handle that case for you), make sure you keep a reference around to that listening port object so you can call <cite>IListeningPort.stopListening &lt;twisted.internet.interfaces.IListeningPort.stopListening&gt;</cite> on it.
Finally, keep in mind that <tt class="docutils literal">stopListening</tt> itself returns a <tt class="docutils literal">Deferred</tt>, and the port may not have fully stopped listening until that <tt class="docutils literal">Deferred</tt> has fired.</p>
<p>Most server applications will not need to worry about these details.
One example of a case where you would need to be concerned with all of these events would be an implementation of a protocol like non-<tt class="docutils literal">PASV</tt> FTP, where new listening ports need to be bound for the lifetime of a particular action, then disposed of.</p>
</div>
<div class="section" id="clients-and-cancelling">
<h3><a class="toc-backref" href="#id5">Clients and Cancelling</a></h3>
<p><cite>connectProtocol &lt;twisted.internet.endpoints.connectProtocol&gt;</cite> connects a <cite>Protocol &lt;twisted.internet.protocol.Protocol&gt;</cite> instance to a given <cite>IStreamClientEndpoint &lt;twisted.internet.interfaces.IStreamClientEndpoint&gt;</cite>. It returns a <tt class="docutils literal">Deferred</tt> which fires with the <tt class="docutils literal">Protocol</tt> once the connection has been made.
Connection attempts may fail, and so that <cite>Deferred &lt;twisted.internet.defer.Deferred&gt;</cite> may also errback.
If it does so, you will have to try again; no further attempts will be made.
See the <a class="reference external" href="https://judgegregg.github.io/pelitwi/pages/writing-clients.html">client documentation</a> for an example use.</p>
<p><cite>connectProtocol &lt;twisted.internet.endpoints.connectProtocol&gt;</cite> is a wrapper around a lower-level API:
<cite>IStreamClientEndpoint.connect &lt;twisted.internet.interfaces.IStreamClientEndpoint.connect&gt;</cite> will use a protocol factory for a new outgoing connection attempt.
It returns a <tt class="docutils literal">Deferred</tt> which fires with the <tt class="docutils literal">IProtocol</tt> returned from the factory's <tt class="docutils literal">buildProtocol</tt> method, or errbacks with the connection failure.</p>
<p>Connection attempts may also take a long time, and your users may become bored and wander off.
If this happens, and your code decides, for whatever reason, that you've been waiting for the connection too long, you can call <cite>Deferred.cancel &lt;twisted.internet.defer.Deferred.cancel&gt;</cite> on the <tt class="docutils literal">Deferred</tt> returned from <cite>connect &lt;twisted.internet.interfaces.IStreamClientEndpoint.connect&gt;</cite> or <cite>connectProtocol &lt;twisted.internet.endpoints.connectProtocol&gt;</cite>, and the underlying machinery should give up on the connection.
This should cause the <tt class="docutils literal">Deferred</tt> to errback, usually with <cite>CancelledError &lt;twisted.internet.defer.CancelledError&gt;</cite>;
although you should consult the documentation for your particular endpoint type to see if it may do something different.</p>
<p>Although some endpoint types may imply a built-in timeout, the
interface does not guarantee one. If you don't have any way for the
application to cancel a wayward connection attempt, the attempt may just
keep waiting forever.  For example, a very simple 30-second timeout could be
implemented like this:</p>
<div class="highlight"><pre><span></span><span class="n">attempt</span> <span class="o">=</span> <span class="n">connectProtocol</span><span class="p">(</span><span class="n">myEndpoint</span><span class="p">,</span> <span class="n">myProtocol</span><span class="p">)</span>
<span class="n">reactor</span><span class="o">.</span><span class="n">callLater</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="n">attempt</span><span class="o">.</span><span class="n">cancel</span><span class="p">)</span>
</pre></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you've used <tt class="docutils literal">ClientFactory</tt> before, keep in mind that the <tt class="docutils literal">connect</tt> method takes a <tt class="docutils literal">Factory</tt>, not a <tt class="docutils literal">ClientFactory</tt>.
Even if you pass a <tt class="docutils literal">ClientFactory</tt> to <tt class="docutils literal">endpoint.connect</tt>, its <tt class="docutils literal">clientConnectionFailed</tt> and <tt class="docutils literal">clientConnectionLost</tt> methods will not be called.
In particular, clients that extend <tt class="docutils literal">ReconnectingClientFactory</tt> won't reconnect. The next section describes how to set up reconnecting clients on endpoints.</p>
</div>
</div>
<div class="section" id="persistent-client-connections">
<h3><a class="toc-backref" href="#id6">Persistent Client Connections</a></h3>
<p><cite>twisted.application.internet.ClientService</cite> can maintain a persistent outgoing connection to a server which can be started and stopped along with your application.</p>
<p>One popular protocol to maintain a long-lived client connection to is IRC, so for an example of <tt class="docutils literal">ClientService</tt>, here's how you would make a long-lived encrypted connection to an IRC server (other details, like how to authenticate, omitted for brevity):</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">twisted.internet.protocol</span> <span class="kn">import</span> <span class="n">Factory</span>
<span class="kn">from</span> <span class="nn">twisted.internet.endpoints</span> <span class="kn">import</span> <span class="n">clientFromString</span>
<span class="kn">from</span> <span class="nn">twisted.words.protocols.irc</span> <span class="kn">import</span> <span class="n">IRCClient</span>
<span class="kn">from</span> <span class="nn">twisted.application.internet</span> <span class="kn">import</span> <span class="n">ClientService</span>
<span class="kn">from</span> <span class="nn">twisted.internet</span> <span class="kn">import</span> <span class="n">reactor</span>

<span class="n">myEndpoint</span> <span class="o">=</span> <span class="n">clientFromString</span><span class="p">(</span><span class="n">reactor</span><span class="p">,</span> <span class="s2">"tls:example.com:6997"</span><span class="p">)</span>
<span class="n">myFactory</span> <span class="o">=</span> <span class="n">Factory</span><span class="o">.</span><span class="n">forProtocol</span><span class="p">(</span><span class="n">IRCClient</span><span class="p">)</span>

<span class="n">myReconnectingService</span> <span class="o">=</span> <span class="n">ClientService</span><span class="p">(</span><span class="n">myEndpoint</span><span class="p">,</span> <span class="n">myFactory</span><span class="p">)</span>
</pre></div>
<p>If you already have a parent service, you can add the reconnecting service as a child service:</p>
<div class="highlight"><pre><span></span><span class="n">parentService</span><span class="o">.</span><span class="n">addService</span><span class="p">(</span><span class="n">myReconnectingService</span><span class="p">)</span>
</pre></div>
<p>If you do not have a parent service, you can start and stop the reconnecting service using its <tt class="docutils literal">startService</tt> and <tt class="docutils literal">stopService</tt> methods.</p>
<p><tt class="docutils literal">ClientService.stopService</tt> returns a <tt class="docutils literal">Deferred</tt> that fires once the current connection closes or the current connection attempt is cancelled.</p>
</div>
</div>
<div class="section" id="getting-the-active-client">
<h2><a class="toc-backref" href="#id7">Getting The Active Client</a></h2>
<p>When maintaining a long-lived connection, it's often useful to be able to get the current connection (if the connection is active) or wait for the next connection (if a connection attempt is currently in progress).
For example, we might want to pass our <tt class="docutils literal">ClientService</tt> from the previous example to some code that can send IRC notifications in response to some external event.
The <tt class="docutils literal">ClientService.whenConnected</tt> method returns a <tt class="docutils literal">Deferred</tt> that fires with the next available <tt class="docutils literal">Protocol</tt> instance.
You can use it like so:</p>
<div class="highlight"><pre><span></span><span class="n">waitForConnection</span> <span class="o">=</span> <span class="n">myReconnectingService</span><span class="o">.</span><span class="n">whenConnected</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">connectedNow</span><span class="p">(</span><span class="n">clientForIRC</span><span class="p">):</span>
    <span class="n">clientForIRC</span><span class="o">.</span><span class="n">say</span><span class="p">(</span><span class="s2">"#bot-test"</span><span class="p">,</span> <span class="s2">"hello, world!"</span><span class="p">)</span>
<span class="n">waitForConnection</span><span class="o">.</span><span class="n">addCallback</span><span class="p">(</span><span class="n">connectedNow</span><span class="p">)</span>
</pre></div>
<p>Keep in mind that you may need to wrap this up for your particular application, since when no existing connection is available, the callback is executed just as soon as the connection is established.
For example, that little snippet is slightly oversimplified: at the time <tt class="docutils literal">connectedNow</tt> is run, the bot hasn't authenticated or joined the channel yet, so its message will be refused.
A real-life IRC bot would need to have its own method for waiting until the connection is fully ready for chat before chatting.</p>
</div>
<div class="section" id="reporting-an-initial-failure">
<h2><a class="toc-backref" href="#id8">Reporting an Initial Failure</a></h2>
<p>Often times, a failure of the very first connection attempt is special.
It may indicate a problem that won't go away by just trying harder.
The service may be configured with the wrong hostname, or the user may not have an internet connection at all (perhaps they forgot to turn on their wifi adapter).</p>
<p>Applications can ask <tt class="docutils literal">whenConnected</tt> to make their <tt class="docutils literal">Deferred</tt> fail if the service makes one or more connection attempts in a row without success.
You can pass the <tt class="docutils literal">failAfterFailures</tt> parameter into <tt class="docutils literal">ClientService</tt> to set this threshold.</p>
<p>By calling <tt class="docutils literal">whenConnected(failAfterFailures=1)</tt> when the service is first started (just before or just after <tt class="docutils literal">startService</tt>), your application will get notification of an initial connection failure.</p>
<p>Setting it to 1 makes it fail after a single connection failure.
Setting it to 2 means it will try once, wait a bit, try again, and then either fail or succeed depending upon the outcome of the second connection attempt.
You can use 3 or more too, if you're feeling particularly patient.
The default of <tt class="docutils literal">None</tt> means it will wait forever for a successful connection.</p>
<p>Regardless of <tt class="docutils literal">failAfterFailures</tt>, the <tt class="docutils literal">Deferred</tt> will always fail with <cite>CancelledError &lt;twisted.internet.defer.CancelledError&gt;</cite> if the service is stopped before a connection is made.</p>
<div class="highlight"><pre><span></span><span class="n">waitForConnection</span> <span class="o">=</span> <span class="n">myReconnectingService</span><span class="o">.</span><span class="n">whenConnected</span><span class="p">(</span><span class="n">failAfterFailures</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">connectedNow</span><span class="p">(</span><span class="n">clientForIRC</span><span class="p">):</span>
    <span class="n">clientForIRC</span><span class="o">.</span><span class="n">say</span><span class="p">(</span><span class="s2">"#bot-test"</span><span class="p">,</span> <span class="s2">"hello, world!"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">failed</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"initial connection failed: </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="p">(</span><span class="n">f</span><span class="p">,))</span>
    <span class="c1"># now you should stop the service and report the error upwards</span>
<span class="n">waitForConnection</span><span class="o">.</span><span class="n">addCallbacks</span><span class="p">(</span><span class="n">connectedNow</span><span class="p">,</span> <span class="n">failed</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="retry-policies">
<h2><a class="toc-backref" href="#id9">Retry Policies</a></h2>
<p><tt class="docutils literal">ClientService</tt> will immediately attempt an outgoing connection when <tt class="docutils literal">startService</tt> is called.
If that connection attempt fails for any reason (name resolution, connection refused, network unreachable, and so on), it will retry according to the policy specified in the <tt class="docutils literal">retryPolicy</tt> constructor argument.
By default, <tt class="docutils literal">ClientService</tt> will use an exponential backoff algorithm with a minimum delay of 1 second and a maximum delay of 1 minute, and a jitter of up to 1 additional second to prevent stampeding-herd performance cascades.
This is a good default, and if you do not have highly specialized requirements, you probably want to use it.
If you need to tune these parameters, you have two options:</p>
<ol class="arabic">
<li><p class="first">You can pass your own timeout policy to <tt class="docutils literal">ClientService</tt>'s constructor.
A timeout policy is a callable that takes the number of failed attempts, and computes a delay until the next connection attempt.
So, for example, if you are <em>really really sure</em> that you want to reconnect <em>every single second</em> if the service you are talking to goes down, you can do this:</p>
<div class="highlight"><pre><span></span><span class="n">myReconnectingService</span> <span class="o">=</span> <span class="n">ClientService</span><span class="p">(</span><span class="n">myEndpoint</span><span class="p">,</span> <span class="n">myFactory</span><span class="p">,</span> <span class="n">retryPolicy</span><span class="o">=</span><span class="k">lambda</span> <span class="n">ignored</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
<p>Of course, unless you have only one client and only one server and they're both on localhost, this sort of policy is likely to cause massive performance degradation and thundering herd resource contention in the event of your server's failure, so you probably want to take the second option...</p>
</li>
<li><p class="first">You can tweak the default exponential backoff policy with a few parameters by passing the result of <cite>twisted.application.internet.backoffPolicy</cite> to the <tt class="docutils literal">retryPolicy</tt> argument.
For example, if you want to make it triple the delay between attempts, but start with a faster connection interval (half a second instead of one second), you could do it like so:</p>
<div class="highlight"><pre><span></span><span class="n">myReconnectingService</span> <span class="o">=</span> <span class="n">ClientService</span><span class="p">(</span>
    <span class="n">myEndpoint</span><span class="p">,</span> <span class="n">myFactory</span><span class="p">,</span>
    <span class="n">retryPolicy</span><span class="o">=</span><span class="n">backoffPolicy</span><span class="p">(</span><span class="n">initialDelay</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">3.0</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Before endpoints, reconnecting clients were created as subclasses of <tt class="docutils literal">ReconnectingClientFactory</tt>.
These subclasses were required to call <tt class="docutils literal">resetDelay</tt>.
One of the many advantages of using endpoints is that these special subclasses are no longer needed.
<tt class="docutils literal">ClientService</tt> accepts ordinary <tt class="docutils literal">IProtocolFactory</tt> providers.</p>
</div>
</div>
<div class="section" id="maximizing-the-return-on-your-endpoint-investment">
<h2><a class="toc-backref" href="#id10">Maximizing the Return on your Endpoint Investment</a></h2>
<p>Directly constructing an endpoint in your application is rarely the
best option, because it ties your application to a particular type of
transport. The strength of the endpoints API is in separating the
construction of the endpoint (figuring out where to connect or listen) and
its activation (actually connecting or listening).</p>
<p>If you are implementing a library that needs to listen for
connections or make outgoing connections, when possible, you should write
your code to accept client and server endpoints as parameters to functions
or to your objects' constructors. That way, application code that calls
your library can provide whatever endpoints are appropriate.</p>
<p>If you are writing an application and you need to construct endpoints yourself, you can allow users to specify arbitrary endpoints described by a string using the <cite>clientFromString &lt;twisted.internet.endpoints.clientFromString&gt;</cite> and <cite>serverFromString &lt;twisted.internet.endpoints.serverFromString&gt;</cite> APIs.
Since these APIs just take a string, they provide flexibility:
if Twisted adds support for new types of endpoints (for example, IPv6 endpoints, or WebSocket endpoints), your application will automatically be able to take advantage of them with no changes to its code.</p>
<div class="section" id="endpoints-aren-t-always-the-answer">
<h3><a class="toc-backref" href="#id11">Endpoints Aren't Always the Answer</a></h3>
<p>For many use-cases, especially the common case of a <tt class="docutils literal">twistd</tt> plugin which runs a long-running server that just binds a simple port, you might not want to use the endpoints APIs directly.
Instead, you may want to construct an <a class="reference external" href="{filename}twisted.application.service.IService.rst">IService</a>, using <cite>strports.service &lt;twisted.application.strports.service&gt;</cite>, which will fit neatly into the required structure of <cite>the twistd plugin API &lt;plugin&gt;</cite>.
This doesn't give your application much control - the port starts listening at startup and stops listening at shutdown - but it does provide the same flexibility in terms of what type of server endpoint your application will support.</p>
<p>It is, however, almost always preferable to use an endpoint rather than calling a lower-level APIs like <cite>connectTCP &lt;twisted.internet.interfaces.IReactorTCP.connectTCP&gt;</cite>, <cite>listenTCP &lt;twisted.internet.interfaces.IReactorTCP.listenTCP&gt;</cite>, etc, directly.
By accepting an arbitrary endpoint rather than requiring a specific reactor interface, you leave your application open to lots of interesting transport-layer extensibility for the future.</p>
</div>
</div>
<div class="section" id="endpoint-types-included-with-twisted">
<h2><a class="toc-backref" href="#id12">Endpoint Types Included With Twisted</a></h2>
<p>The parser used by <tt class="docutils literal">clientFromString</tt> and <tt class="docutils literal">serverFromString</tt> is extensible via third-party plugins, so the endpoints available on your system depend on what packages you have installed.
However, Twisted itself includes a set of basic endpoints that will always be available.</p>
<div class="section" id="clients">
<h3><a class="toc-backref" href="#id13">Clients</a></h3>
<dl class="docutils">
<dt>TCP</dt>
<dd><p class="first">Supported arguments: <tt class="docutils literal">host</tt>, <tt class="docutils literal">port</tt>, <tt class="docutils literal">timeout</tt>.
<tt class="docutils literal">timeout</tt> is optional.</p>
<p class="last">For example, <tt class="docutils literal">tcp:host=twistedmatrix.com:port=80:timeout=15</tt>.</p>
</dd>
<dt>TLS</dt>
<dd><p class="first">Required arguments: <tt class="docutils literal">host</tt>, <tt class="docutils literal">port</tt>.</p>
<p>Optional arguments: <tt class="docutils literal">timeout</tt>, <tt class="docutils literal">bindAddress</tt>, <tt class="docutils literal">certificate</tt>, <tt class="docutils literal">privateKey</tt>, <tt class="docutils literal">trustRoots</tt>, <tt class="docutils literal">endpoint</tt>.</p>
<ul class="simple">
<li><tt class="docutils literal">host</tt> is a (UTF-8 encoded) hostname to connect to, as well as the host name to verify against.</li>
<li><tt class="docutils literal">port</tt> is a numeric port number to connect to.</li>
<li><tt class="docutils literal">timeout</tt> and <tt class="docutils literal">bindAddress</tt> have the same meaning as the <tt class="docutils literal">timeout</tt> and <tt class="docutils literal">bindAddress</tt> for TCP clients.</li>
<li><tt class="docutils literal">certificate</tt> is the certificate to use for the client; it should be the path name of a PEM file containing a certificate for which <tt class="docutils literal">privateKey</tt> is the private key.</li>
<li><tt class="docutils literal">privateKey</tt> is the client's private key, matching the certificate specified by <tt class="docutils literal">certificate</tt>.
It should be the path name of a PEM file containing an X.509 client certificate.
If <tt class="docutils literal">certificate</tt> is specified but <tt class="docutils literal">privateKey</tt> is unspecified, Twisted will look for the certificate in the same file as specified by <tt class="docutils literal">certificate</tt>.</li>
<li><tt class="docutils literal">trustRoots</tt> specifies a path to a directory of PEM-encoded certificate files.  If you leave this unspecified, Twisted will do its best to use the platform default set of trust roots, which should be the default WebTrust set.</li>
<li>the optional <tt class="docutils literal">endpoint</tt> parameter changes the meaning of the <tt class="docutils literal">tls:</tt> endpoint slightly.
Rather than the default of connecting over TCP with the same hostname used for verification, you can connect over <em>any</em> endpoint type.
If you specify the endpoint here, <tt class="docutils literal">host</tt> and <tt class="docutils literal">port</tt> are used for certificate verification purposes only.
Bear in mind you will need to backslash-escape the colons in the endpoint description here.</li>
</ul>
<p>This client connects to the supplied hostname, validates the server's hostname against the supplied hostname, and then upgrades to TLS immediately after validation succeeds.</p>
<p>The simplest example of this would be: <tt class="docutils literal">tls:example.com:443</tt>.</p>
<p>You can use the <tt class="docutils literal">endpoint:</tt> feature with TCP if you want to connect to a host name; for example, if your DNS is not working, but you know that the IP address 7.6.5.4 points to <tt class="docutils literal">awesome.site.example.com</tt>, you could specify: <tt class="docutils literal"><span class="pre">tls:awesome.site.example.com:443:endpoint=tcp\:7.6.5.4\:443</span></tt>.</p>
<p>You can use it with any other endpoint type as well, though; for example, if you had a local UNIX socket that established a tunnel to <tt class="docutils literal">awesome.site.example.com</tt> in <tt class="docutils literal">/var/run/awesome.sock</tt>, you could instead do <tt class="docutils literal"><span class="pre">tls:awesome.site.example.com:443:endpoint=unix\:/var/run/awesome.sock</span></tt>.</p>
<p>Or, from python code:</p>
<pre class="last literal-block">
wrapped = HostnameEndpoint('example.com', 443)
contextFactory = optionsForClientTLS(hostname=u'example.com')
endpoint = wrapClientTLS(contextFactory, wrapped)
conn = endpoint.connect(Factory.forProtocol(Protocol))
</pre>
</dd>
<dt>UNIX</dt>
<dd><p class="first">Supported arguments: <tt class="docutils literal">path</tt>, <tt class="docutils literal">timeout</tt>, <tt class="docutils literal">checkPID</tt>.
<tt class="docutils literal">path</tt> gives a filesystem path to a listening UNIX domain socket server.
<tt class="docutils literal">checkPID</tt> (optional) enables a check of the lock file Twisted-based UNIX domain socket servers use to prove they are still running.</p>
<p class="last">For example, <tt class="docutils literal"><span class="pre">unix:path=/var/run/web.sock</span></tt>.</p>
</dd>
<dt>TCP (Hostname)</dt>
<dd><p class="first">Supported arguments: <tt class="docutils literal">host</tt>, <tt class="docutils literal">port</tt>, <tt class="docutils literal">timeout</tt>.
<tt class="docutils literal">host</tt> is a hostname to connect to.
<tt class="docutils literal">timeout</tt> is optional.
It is a name-based TCP endpoint that returns the connection which is established first amongst the resolved addresses.</p>
<p>For example,</p>
<div class="last"><div class="highlight"><pre><span></span><span class="n">endpoint</span> <span class="o">=</span> <span class="n">HostnameEndpoint</span><span class="p">(</span><span class="n">reactor</span><span class="p">,</span> <span class="s2">"twistedmatrix.com"</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
<span class="n">conn</span> <span class="o">=</span> <span class="n">endpoint</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">Factory</span><span class="o">.</span><span class="n">forProtocol</span><span class="p">(</span><span class="n">Protocol</span><span class="p">))</span>
</pre></div>
</div></dd>
</dl>
<p>SSL (Deprecated)</p>
<blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>You should generally prefer the "TLS" client endpoint, above, unless you need to work with versions of Twisted older than 16.0.
Among other things:</p>
<blockquote class="last">
<ul class="simple">
<li>the <tt class="docutils literal">ssl:</tt> client endpoint requires that you pass ''both'' <tt class="docutils literal">hostname=</tt> (for hostname verification) as well as <tt class="docutils literal">host=</tt> (for a TCP connection address) in order to get hostname verification, which is required for security, whereas <tt class="docutils literal">tls:</tt> does the correct thing by default by using the same hostname for both.</li>
<li>the <tt class="docutils literal">ssl:</tt> client endpoint doesn't work with IPv6, and the <tt class="docutils literal">tls:</tt> endpoint does.</li>
</ul>
</blockquote>
</div>
<p>All TCP arguments are supported, plus: <tt class="docutils literal">certKey</tt>, <tt class="docutils literal">privateKey</tt>, <tt class="docutils literal">caCertsDir</tt>.
<tt class="docutils literal">certKey</tt> (optional) gives a filesystem path to a certificate (PEM format).
<tt class="docutils literal">privateKey</tt> (optional) gives a filesystem path to a private key (PEM format).
<tt class="docutils literal">caCertsDir</tt> (optional) gives a filesystem path to a directory containing trusted CA certificates to use to verify the server certificate.</p>
<p>For example, <tt class="docutils literal"><span class="pre">ssl:host=twistedmatrix.com:port=443:caCertsDir=/etc/ssl/certs</span></tt>.</p>
</blockquote>
</div>
<div class="section" id="servers">
<h3><a class="toc-backref" href="#id14">Servers</a></h3>
<dl class="docutils">
<dt>TCP (IPv4)</dt>
<dd><p class="first">Supported arguments: <tt class="docutils literal">port</tt>, <tt class="docutils literal">interface</tt>, <tt class="docutils literal">backlog</tt>.
<tt class="docutils literal">interface</tt> and <tt class="docutils literal">backlog</tt> are optional.
<tt class="docutils literal">interface</tt> is an IP address (belonging to the IPv4 address family) to bind to.</p>
<p class="last">For example, <tt class="docutils literal">tcp:port=80:interface=192.168.1.1</tt>.</p>
</dd>
<dt>TCP (IPv6)</dt>
<dd><p class="first">All TCP (IPv4) arguments are supported, with <tt class="docutils literal">interface</tt> taking an IPv6 address literal instead.</p>
<p class="last">For example, <tt class="docutils literal"><span class="pre">tcp6:port=80:interface=2001\:0DB8\:f00e\:eb00\:\:1</span></tt>.</p>
</dd>
<dt>SSL</dt>
<dd><p class="first">All TCP arguments are supported, plus: <tt class="docutils literal">certKey</tt>, <tt class="docutils literal">privateKey</tt>, <tt class="docutils literal">extraCertChain</tt>, <tt class="docutils literal">sslmethod</tt>, and <tt class="docutils literal">dhParameters</tt>.
<tt class="docutils literal">certKey</tt> (optional, defaults to the value of privateKey) gives a filesystem path to a certificate (PEM format).
<tt class="docutils literal">privateKey</tt> gives a filesystem path to a private key (PEM format).
<tt class="docutils literal">extraCertChain</tt> gives a filesystem path to a file with one or more concatenated certificates in PEM format that establish the chain from a root CA to the one that signed your certificate.
<tt class="docutils literal">sslmethod</tt> indicates which SSL/TLS version to use (a value like <tt class="docutils literal">TLSv1_METHOD</tt>).
<tt class="docutils literal">dhParameters</tt> gives a filesystem path to a file in PEM format with parameters that are required for Diffie-Hellman key exchange.
Since the this is required for the <tt class="docutils literal">DHE</tt>-family of ciphers that offer perfect forward secrecy (PFS), it is recommended to specify one.
Such a file can be created using <tt class="docutils literal">openssl dhparam <span class="pre">-out</span> dh_param_1024.pem <span class="pre">-2</span> 1024</tt>.
Please refer to <a class="reference external" href="http://www.openssl.org/docs/apps/dhparam.html">OpenSSL's documentation on dhparam</a> for further details.</p>
<p class="last">For example, <tt class="docutils literal"><span class="pre">ssl:port=443:privateKey=/etc/ssl/server.pem:extraCertChain=/etc/ssl/chain.pem:sslmethod=SSLv3_METHOD:dhParameters=dh_param_1024.pem</span></tt>.</p>
</dd>
<dt>UNIX</dt>
<dd><p class="first">Supported arguments: <tt class="docutils literal">address</tt>, <tt class="docutils literal">mode</tt>, <tt class="docutils literal">backlog</tt>, <tt class="docutils literal">lockfile</tt>.
<tt class="docutils literal">address</tt> gives a filesystem path to listen on with a UNIX domain socket server.
<tt class="docutils literal">mode</tt> (optional) gives the filesystem permission/mode (in octal) to apply to that socket.
<tt class="docutils literal">lockfile</tt> enables use of a separate lock file to prove the server is still running.</p>
<p class="last">For example, <tt class="docutils literal"><span class="pre">unix:address=/var/run/web.sock:lockfile=1</span></tt>.</p>
</dd>
<dt>systemd</dt>
<dd><p class="first">Supported arguments: <tt class="docutils literal">domain</tt>, <tt class="docutils literal">index</tt>.
<tt class="docutils literal">domain</tt> indicates which socket domain the inherited file descriptor belongs to (eg INET, INET6).
<tt class="docutils literal">index</tt> indicates an offset into the array of file descriptors which have been inherited from systemd.</p>
<p>For example, <tt class="docutils literal">systemd:domain=INET6:index=3</tt>.</p>
<p class="last">See also <a class="reference external" href="https://judgegregg.github.io/pelitwi/pages/deploying-twisted-with-systemd.html">Deploying Twisted with systemd</a>.</p>
</dd>
<dt>PROXY</dt>
<dd><p class="first">The PROXY protocol is a stream wrapper and can be applied any of the other server endpoints by placing <tt class="docutils literal">haproxy:</tt> in front of a normal port definition.</p>
<p>For example, <tt class="docutils literal">haproxy:tcp:port=80:interface=192.168.1.1</tt> or <tt class="docutils literal"><span class="pre">haproxy:ssl:port=443:privateKey=/etc/ssl/server.pem:extraCertChain=/etc/ssl/chain.pem:sslmethod=SSLv3_METHOD:dhParameters=dh_param_1024.pem</span></tt>.</p>
<p class="last">The PROXY protocol provides a way for load balancers and reverse proxies to send down the real IP of a connection's source and destination without relying on X-Forwarded-For headers. A Twisted service using this endpoint wrapper must run behind a service that sends valid PROXY protocol headers. For more on the protocol see <a class="reference external" href="http://www.haproxy.org/download/1.5/doc/proxy-protocol.txt">the formal specification</a>. Both version one and two of the protocol are currently supported.</p>
</dd>
</dl>

</div>
</div>

        </div>
        </div>
        </div>
<div class="sphinxsidebar">
<div class="sphinxsidebarwrapper">
<div class="toc" id="">
<p class="topic-title">Table Of Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id1">Introduction</a></li>
<li><a class="reference internal" href="#constructing-and-using-endpoints" id="id2">Constructing and Using Endpoints</a><ul>
<li><a class="reference internal" href="#there-s-not-much-to-it" id="id3">There's Not Much To It</a></li>
<li><a class="reference internal" href="#servers-and-stopping" id="id4">Servers and Stopping</a></li>
<li><a class="reference internal" href="#clients-and-cancelling" id="id5">Clients and Cancelling</a></li>
<li><a class="reference internal" href="#persistent-client-connections" id="id6">Persistent Client Connections</a></li>
</ul>
</li>
<li><a class="reference internal" href="#getting-the-active-client" id="id7">Getting The Active Client</a></li>
<li><a class="reference internal" href="#reporting-an-initial-failure" id="id8">Reporting an Initial Failure</a></li>
<li><a class="reference internal" href="#retry-policies" id="id9">Retry Policies</a></li>
<li><a class="reference internal" href="#maximizing-the-return-on-your-endpoint-investment" id="id10">Maximizing the Return on your Endpoint Investment</a><ul>
<li><a class="reference internal" href="#endpoints-aren-t-always-the-answer" id="id11">Endpoints Aren't Always the Answer</a></li>
</ul>
</li>
<li><a class="reference internal" href="#endpoint-types-included-with-twisted" id="id12">Endpoint Types Included With Twisted</a><ul>
<li><a class="reference internal" href="#clients" id="id13">Clients</a></li>
<li><a class="reference internal" href="#servers" id="id14">Servers</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div>    </div>

    </section>

        <div id="footer"><hr>
                <div> </div>
                <p class="left2">
        Copyright 2021, Twisted Matrix Labs. Ver 21.2.0. Built on 2021-02-28.<br />
        Site design<br />
        By <a href="http://huw.ugbox.net/">huw.wilkins.</a>

                </p>
                <p class="right"></p>
        </div>


</body>
</html>