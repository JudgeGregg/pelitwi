<!DOCTYPE html>
<html lang="en">
<head>
          <title>Test Pelican - PB Copyable: Passing Complex Types</title>
        <meta charset="utf-8" />
        <meta name="generator" content="Pelican" />

        <meta name="Description" content="An event-driven networking engine written in Python and MIT licensed." />

        <link rel="stylesheet" type="text/css" href="https://judgegregg.github.io/pelitwi/theme/css/twistedtrac.css" />


</head>

<body>
        <div id="banner">
                <div id="top_grad"></div>
                <div id="tab">
                        <a href="https://twistedmatrix.com/trac/wiki">HOME</a>
                        <a href="https://twistedmatrix.com/trac/wiki/FrequentlyAskedQuestions">FAQ</a>
                        <a href="/">DOCS</a>
                        <a href="https://twistedmatrix.com/trac/wiki/Downloads">DOWNLOAD</a>
                </div>

                <div id="header">
                        <a id="logo" href="https://judgegregg.github.io/pelitwi/"><img src="https://judgegregg.github.io/pelitwi/theme/images/trac_banner.png" alt="Twisted" /></a>
                </div>
        </div>

<div id="mainnav" class="related">
	<ul>
		<li><a href="https://judgegregg.github.io/pelitwi">Twisted 21.2.0 documentation</a> Â»</li>
	</ul>
</div>
        <div id="ctxtnav" class="nav">
        </div>

    <section>

    <div class="document">
        <div class="documentwrapper">
        <div class="bodywrapper">
        <h1>PB Copyable: Passing Complex Types</h1>
        
        <div class="entry-content">
        <div class="section" id="overview">
<h2><a class="toc-backref" href="#id12">Overview</a></h2>
<p>This chapter focuses on how to use PB to pass complex types (specifically
class instances) to and from a remote process. The first section is on
simply copying the contents of an object to a remote process (<cite>pb.Copyable &lt;twisted.spread.pb.Copyable&gt;</cite> ). The second covers how
to copy those contents once, then update them later when they change (<cite>Cacheable &lt;twisted.spread.pb.Cacheable&gt;</cite> ).</p>
</div>
<div class="section" id="motivation">
<h2><a class="toc-backref" href="#id13">Motivation</a></h2>
<p>From the <a class="reference external" href="https://judgegregg.github.io/pelitwi/pages/using-perspective-broker.html">previous chapter</a> , you've seen how to
pass basic types to a remote process, by using them in the arguments or
return values of a <cite>callRemote &lt;twisted.spread.pb.RemoteReference.callRemote&gt;</cite> function. However,
if you've experimented with it, you may have discovered problems when trying
to pass anything more complicated than a primitive int/list/dict/string
type, or another <cite>pb.Referenceable &lt;twisted.spread.pb.Referenceable&gt;</cite> object. At some point you want
to pass entire objects between processes, instead of having to reduce them
down to dictionaries on one end and then re-instantiating them on the
other.</p>
</div>
<div class="section" id="passing-objects">
<h2><a class="toc-backref" href="#id14">Passing Objects</a></h2>
<p>The most obvious and straightforward way to send an object to a remote
process is with something like the following code. It also happens that this
code doesn't work, as will be explained below.</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LilyPond</span><span class="p">:</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frogs</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">frogs</span> <span class="o">=</span> <span class="n">frogs</span>

<span class="n">pond</span> <span class="o">=</span> <span class="n">LilyPond</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="n">ref</span><span class="o">.</span><span class="n">callRemote</span><span class="p">(</span><span class="s2">"sendPond"</span><span class="p">,</span> <span class="n">pond</span><span class="p">)</span>
</pre></div>
<p>If you try to run this, you might hope that a suitable remote end which
implements the <tt class="docutils literal">remote_sendPond</tt> method would see that method get
invoked with an instance from the <tt class="docutils literal">LilyPond</tt> class. But instead,
you'll encounter the dreaded <cite>InsecureJelly &lt;twisted.spread.jelly.InsecureJelly&gt;</cite> exception. This is
Twisted's way of telling you that you've violated a security restriction,
and that the receiving end refuses to accept your object.</p>
<div class="section" id="security-options">
<h3><a class="toc-backref" href="#id15">Security Options</a></h3>
<p>What's the big deal? What's wrong with just copying a class into another
process' namespace?</p>
<p>Reversing the question might make it easier to see the issue: what is the
problem with accepting a stranger's request to create an arbitrary object in
your local namespace? The real question is how much power you are granting
them: what actions can they convince you to take on the basis of the bytes
they are sending you over that remote connection.</p>
<p>Objects generally represent more power than basic types like strings and
dictionaries because they also contain (or reference) code, which can modify
other data structures when executed. Once previously-trusted data is
subverted, the rest of the program is compromised.</p>
<p>The built-in Python "batteries included" classes are relatively
tame, but you still wouldn't want to let a foreign program use them to
create arbitrary objects in your namespace or on your computer. Imagine a
protocol that involved sending a file-like object with a <tt class="docutils literal">read()</tt>
method that was supposed to used later to retrieve a document. Then imagine
what if that object were created with
<tt class="docutils literal"><span class="pre">os.fdopen("~/.gnupg/secring.gpg")</span></tt> . Or an instance of
<tt class="docutils literal"><span class="pre">telnetlib.Telnet("localhost",</span> "chargen")</tt> .</p>
<p>Classes you've written for your own program are likely to have far more
power. They may run code during <tt class="docutils literal">__init__</tt> , or even have special
meaning simply because of their existence. A program might have
<tt class="docutils literal">User</tt> objects to represent user accounts, and have a rule that
says all <tt class="docutils literal">User</tt> objects in the system are referenced when
authorizing a login session. (In this system, <tt class="docutils literal">User.__init__</tt>
would probably add the object to a global list of known users). The simple
act of creating an object would give access to somebody. If you could be
tricked into creating a bad object, an unauthorized user would get
access.</p>
<p>So object creation needs to be part of a system's security design. The
dotted line between "trusted inside" and "untrusted outside" needs
to describe what may be done in response to outside events. One of those
events is the receipt of an object through a PB remote procedure call, which
is a request to create an object in your "inside" namespace. The
question is what to do in response to it. For this reason, you must
explicitly specify what remote classes will be accepted, and how their
local representatives are to be created.</p>
</div>
<div class="section" id="what-class-to-use">
<h3><a class="toc-backref" href="#id16">What class to use?</a></h3>
<p>Another basic question to answer before we can do anything useful with an
incoming serialized object is: what class should we create? The simplistic
answer is to create the "same kind" that was serialized on the sender's
end of the wire, but this is not as easy or as straightforward as you might
think. Remember that the request is coming from a different program, using a
potentially different set of class libraries. In fact, since PB has also
been implemented in Java, Emacs-Lisp, and other languages, there's no
guarantee that the sender is even running Python! All we know on the
receiving end is a list of two things which describe the instance they are
trying to send us: the name of the class, and a representation of the
contents of the object.</p>
<p>PB lets you specify the mapping from remote class names to local classes
with the <cite>setUnjellyableForClass &lt;twisted.spread.jelly.setUnjellyableForClass&gt;</cite> function  <a class="footnote-reference" href="#id7" id="id1">[1]</a> .</p>
<p>This function takes a remote/sender class reference (either the
fully-qualified name as used by the sending end, or a class object from
which the name can be extracted), and a local/recipient class (used to
create the local representation for incoming serialized objects). Whenever
the remote end sends an object, the class name that they transmit is looked
up in the table controlled by this function. If a matching class is found,
it is used to create the local object. If not, you get the
<tt class="docutils literal">InsecureJelly</tt> exception.</p>
<p>In general you expect both ends to share the same codebase: either you
control the program that is running on both ends of the wire, or both
programs share some kind of common language that is implemented in code
which exists on both ends. You wouldn't expect them to send you an object of
the MyFooziWhatZit class unless you also had a definition for that class. So
it is reasonable for the Jelly layer to reject all incoming classes except
the ones that you have explicitly marked with
<tt class="docutils literal">setUnjellyableForClass</tt> . But keep in mind that the sender's idea
of a <tt class="docutils literal">User</tt> object might differ from the recipient's, either
through namespace collisions between unrelated packages, version skew
between nodes that haven't been updated at the same rate, or a malicious
intruder trying to cause your code to fail in some interesting or
potentially vulnerable way.</p>
</div>
</div>
<div class="section" id="pb-copyable">
<h2><a class="toc-backref" href="#id17">pb.Copyable</a></h2>
<p>Ok, enough of this theory. How do you send a fully-fledged object from
one side to the other?</p>
<p><cite>copy_sender.py &lt;listings/pb/copy_sender.py&gt;</cite></p>
<p><cite>copy_receiver.tac &lt;listings/pb/copy_receiver.tac&gt;</cite></p>
<p>The sending side has a class called <tt class="docutils literal">LilyPond</tt> . To make this
eligible for transport through <tt class="docutils literal">callRemote</tt> (either as an
argument, a return value, or something referenced by either of those [like a
dictionary value]), it must inherit from one of the four <cite>Serializable &lt;twisted.spread.pb.Serializable&gt;</cite> classes. In this section,
we focus on <cite>Copyable &lt;twisted.spread.pb.Copyable&gt;</cite> .
The copyable subclass of <tt class="docutils literal">LilyPond</tt> is called
<tt class="docutils literal">CopyPond</tt> . We create an instance of it and send it through
<tt class="docutils literal">callRemote</tt> as an argument to the receiver's
<tt class="docutils literal">remote_takePond</tt> method. The Jelly layer will serialize
("jelly" ) that object as an instance with a class name of"copy_sender.CopyPond" and some chunk of data that represents the
object's state. <tt class="docutils literal">pond.__class__.__module__</tt> and
<tt class="docutils literal">pond.__class__.__name__</tt> are used to derive the class name
string. The object's <cite>getStateToCopy &lt;twisted.spread.pb.Copyable.getStateToCopy&gt;</cite> method is
used to get the state: this is provided by <cite>pb.Copyable &lt;twisted.spread.pb.Copyable&gt;</cite> , and the default just retrieves
<tt class="docutils literal">self.__dict__</tt> . This works just like the optional
<tt class="docutils literal">__getstate__</tt> method used by <tt class="docutils literal">pickle</tt> . The pair of
name and state are sent over the wire to the receiver.</p>
<p>The receiving end defines a local class named <tt class="docutils literal">ReceiverPond</tt>
to represent incoming <tt class="docutils literal">LilyPond</tt> instances. This class derives
from the sender's <tt class="docutils literal">LilyPond</tt> class (with a fully-qualified name
of <tt class="docutils literal">copy_sender.LilyPond</tt> ), which specifies how we expect it to
behave. We trust that this is the same <tt class="docutils literal">LilyPond</tt> class as the
sender used. (At the very least, we hope ours will be able to accept a state
created by theirs). It also inherits from <cite>pb.RemoteCopy &lt;twisted.spread.pb.RemoteCopy&gt;</cite> , which is a requirement for all
classes that act in this local-representative role (those which are given to
the second argument of <tt class="docutils literal">setUnjellyableForClass</tt> ).
<tt class="docutils literal">RemoteCopy</tt> provides the methods that tell the Jelly layer how
to create the local object from the incoming serialized state.</p>
<p>Then <tt class="docutils literal">setUnjellyableForClass</tt> is used to register the two
classes. This has two effects: instances of the remote class (the first
argument) will be allowed in through the security layer, and instances of
the local class (the second argument) will be used to contain the state that
is transmitted when the sender serializes the remote object.</p>
<p>When the receiver unserializes ("unjellies" ) the object, it will
create an instance of the local <tt class="docutils literal">ReceiverPond</tt> class, and hand
the transmitted state (usually in the form of a dictionary) to that object's
<cite>setCopyableState &lt;twisted.spread.pb.RemoteCopy.setCopyableState&gt;</cite> method.
This acts just like the <tt class="docutils literal">__setstate__</tt> method that
<tt class="docutils literal">pickle</tt> uses when unserializing an object.
<tt class="docutils literal">getStateToCopy</tt> /<tt class="docutils literal">setCopyableState</tt> are distinct from
<tt class="docutils literal">__getstate__</tt> /<tt class="docutils literal">__setstate__</tt> to allow objects to be
persisted (across time) differently than they are transmitted (across
[memory]space).</p>
<p>When this is run, it produces the following output:</p>
<div class="highlight"><pre><span></span><span class="go">[-] twisted.spread.pb.PBServerFactory starting on 8800</span>
<span class="go">[-] Starting factory &lt;twisted.spread.pb.PBServerFactory instance at</span>
<span class="go">0x406159cc&gt;</span>
<span class="go">[Broker,0,127.0.0.1]  got pond: &lt;__builtin__.ReceiverPond instance at</span>
<span class="go">0x406ec5ec&gt;</span>
<span class="go">[Broker,0,127.0.0.1] 7 frogs</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="gp">$ </span>./copy_sender.py
<span class="go">7 frogs</span>
<span class="go">copy_sender.CopyPond</span>
<span class="go">pond arrived safe and sound</span>
<span class="go">Main loop terminated.</span>
<span class="gp">$</span>
</pre></div>
<div class="section" id="controlling-the-copied-state">
<h3><a class="toc-backref" href="#id18">Controlling the Copied State</a></h3>
<p>By overriding <tt class="docutils literal">getStateToCopy</tt> and
<tt class="docutils literal">setCopyableState</tt> , you can control how the object is transmitted
over the wire. For example, you might want perform some data-reduction:
pre-compute some results instead of sending all the raw data over the wire.
Or you could replace references to a local object on the sender's side with
markers before sending, then upon receipt replace those markers with
references to a receiver-side proxy that could perform the same operations
against a local cache of data.</p>
<p>Another good use for <tt class="docutils literal">getStateToCopy</tt> is to implement "local-only" attributes: data that is only accessible by the local
process, not to any remote users. For example, a <tt class="docutils literal">.password</tt>
attribute could be removed from the object state before sending to a remote
system. Combined with the fact that <tt class="docutils literal">Copyable</tt> objects return
unchanged from a round trip, this could be used to build a
challenge-response system (in fact PB does this with
<tt class="docutils literal">pb.Referenceable</tt> objects to implement authorization as
described <a class="reference external" href="https://judgegregg.github.io/pelitwi/pages/authentication-with-perspective-broker.html">here</a> ).</p>
<p>Whatever <tt class="docutils literal">getStateToCopy</tt> returns from the sending object will
be serialized and sent over the wire; <tt class="docutils literal">setCopyableState</tt> gets
whatever comes over the wire and is responsible for setting up the state of
the object it lives in.</p>
<p><cite>copy2_classes.py &lt;listings/pb/copy2_classes.py&gt;</cite></p>
<p><cite>copy2_sender.py &lt;listings/pb/copy2_sender.py&gt;</cite></p>
<p><cite>copy2_receiver.py &lt;listings/pb/copy2_receiver.py&gt;</cite></p>
<p>In this example, the classes are defined in a separate source file, which
also sets up the binding between them. The <tt class="docutils literal">SenderPond</tt> and <tt class="docutils literal">ReceiverPond</tt> are unrelated save for this binding: they happen
to implement the same methods, but use different internal instance variables
to accomplish them.</p>
<p>The recipient of the object doesn't even have to import the class
definition into their namespace. It is sufficient that they import the class
definition (and thus execute the <tt class="docutils literal">setUnjellyableForClass</tt>
statement). The Jelly layer remembers the class definition until a matching
object is received. The sender of the object needs the definition, of
course, to create the object in the first place.</p>
<p>When run, the <tt class="docutils literal">copy2</tt> example emits the following:</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>twistd -n -y copy2_receiver.py
<span class="go">[-] twisted.spread.pb.PBServerFactory starting on 8800</span>
<span class="go">[-] Starting factory &lt;twisted.spread.pb.PBServerFactory instance at</span>
<span class="go">0x40604b4c&gt;</span>
<span class="go">[Broker,0,127.0.0.1]  got pond: &lt;copy2_classes.ReceiverPond instance at</span>
<span class="go">0x406eb2ac&gt;</span>
<span class="go">[Broker,0,127.0.0.1]  count 7</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="gp">$ </span>./copy2_sender.py
<span class="go">count 7</span>
<span class="go">pond arrived safe and sound</span>
<span class="go">Main loop terminated.</span>
</pre></div>
</div>
<div class="section" id="things-to-watch-out-for">
<h3><a class="toc-backref" href="#id19">Things To Watch Out For</a></h3>
<ul class="simple">
<li>The first argument to <tt class="docutils literal">setUnjellyableForClass</tt> must refer
to the class <em>as known by the sender</em> . The sender has no way of
knowing about how your local <tt class="docutils literal">import</tt> statements are set up,
and Python's flexible namespace semantics allow you to access the same
class through a variety of different names. You must match whatever the
sender does. Having both ends import the class from a separate file, using
a canonical module name (no "sibling imports" ), is a good way to get
this right, especially when both the sending and the receiving classes are
defined together, with the <tt class="docutils literal">setUnjellyableForClass</tt> immediately
following them.</li>
<li>The class that is sent must inherit from <cite>pb.Copyable &lt;twisted.spread.pb.Copyable&gt;</cite> . The class that is registered to
receive it must inherit from <cite>pb.RemoteCopy &lt;twisted.spread.pb.RemoteCopy&gt;</cite> <a class="footnote-reference" href="#id8" id="id2">[2]</a> .</li>
<li>The same class can be used to send and receive. Just have it inherit
from both <tt class="docutils literal">pb.Copyable</tt> and <tt class="docutils literal">pb.RemoteCopy</tt> . This
will also make it possible to send the same class symmetrically back and
forth over the wire. But don't get confused about when it is coming (and
using <tt class="docutils literal">setCopyableState</tt> ) versus when it is going (using
<tt class="docutils literal">getStateToCopy</tt> ).</li>
<li><cite>InsecureJelly &lt;twisted.spread.jelly.InsecureJelly&gt;</cite>
exceptions are raised by the receiving end. They will be delivered
asynchronously to an <tt class="docutils literal">errback</tt> handler. If you do not add one
to the <tt class="docutils literal">Deferred</tt> returned by <tt class="docutils literal">callRemote</tt> , then you
will never receive notification of the problem.</li>
<li>The class that is derived from <cite>pb.RemoteCopy &lt;twisted.spread.pb.RemoteCopy&gt;</cite> will be created using a
constructor <tt class="docutils literal">__init__</tt> method that takes no arguments. All
setup must be performed in the <tt class="docutils literal">setCopyableState</tt> method. As
the docstring on <cite>RemoteCopy &lt;twisted.spread.pb.RemoteCopy&gt;</cite> says, don't implement a
constructor that requires arguments in a subclass of
<tt class="docutils literal">RemoteCopy</tt> .</li>
</ul>
<!-- XXX: check this, the code around jelly._Unjellier.unjelly:489 tries to avoid -->
<!-- calling <code>__init__</code> just in case the constructor requires -->
<!-- args. -->
</div>
<div class="section" id="more-information">
<h3><a class="toc-backref" href="#id20">More Information</a></h3>
<ul class="simple">
<li><tt class="docutils literal">pb.Copyable</tt> is mostly implemented
in <tt class="docutils literal">twisted.spread.flavors</tt> , and the docstrings there are
the best source of additional information.</li>
<li><tt class="docutils literal">Copyable</tt> is also used in <cite>twisted.web.distrib</cite> to deliver HTTP requests to other
programs for rendering, allowing subtrees of URL space to be delegated to
multiple programs (on multiple machines).</li>
</ul>
</div>
</div>
<div class="section" id="pb-cacheable">
<h2><a class="toc-backref" href="#id21">pb.Cacheable</a></h2>
<p>Sometimes the object you want to send to the remote process is big and
slow. "big" means it takes a lot of data (storage, network bandwidth,
processing) to represent its state. "slow" means that state doesn't
change very frequently. It may be more efficient to send the full state only
once, the first time it is needed, then afterwards only send the differences
or changes in state whenever it is modified. The <cite>pb.Cacheable &lt;twisted.spread.pb.Cacheable&gt;</cite> class provides a framework to
implement this.</p>
<p><cite>pb.Cacheable &lt;twisted.spread.pb.Cacheable&gt;</cite> is derived
from <cite>pb.Copyable &lt;twisted.spread.pb.Copyable&gt;</cite> , so it is
based upon the idea of an object's state being captured on the sending side,
and then turned into a new object on the receiving side. This is extended to
have an object "publishing" on the sending side (derived from <cite>pb.Cacheable &lt;twisted.spread.pb.Cacheable&gt;</cite> ), matched with one"observing" on the receiving side (derived from <cite>pb.RemoteCache &lt;twisted.spread.pb.RemoteCache&gt;</cite> ).</p>
<p>To effectively use <tt class="docutils literal">pb.Cacheable</tt> , you need to isolate changes
to your object into accessor functions (specifically "setter"
functions). Your object needs to get control <em>every</em> single time some
attribute is changed <a class="footnote-reference" href="#id9" id="id3">[3]</a> .</p>
<p>You derive your sender-side class from <tt class="docutils literal">pb.Cacheable</tt> , and you
add two methods: <cite>getStateToCacheAndObserveFor &lt;twisted.spread.pb.Cacheable.getStateToCacheAndObserveFor&gt;</cite>
and <cite>stoppedObserving &lt;twisted.spread.pb.Cacheable.stoppedObserving&gt;</cite> . The first
is called when a remote caching reference is first created, and retrieves
the data with which the cache is first filled. It also provides an
object called the "observer"  <a class="footnote-reference" href="#id10" id="id4">[4]</a> that points at that receiver-side cache. Every time the state of the object
is changed, you give a message to the observer, informing them of the
change. The other method, <tt class="docutils literal">stoppedObserving</tt> , is called when the
remote cache goes away, so that you can stop sending updates.</p>
<p>On the receiver end, you make your cache class inherit from <cite>pb.RemoteCache &lt;twisted.spread.pb.RemoteCache&gt;</cite> , and implement the
<tt class="docutils literal">setCopyableState</tt> as you would for a <tt class="docutils literal">pb.RemoteCopy</tt>
object. In addition, you must implement methods to receive the updates sent
to the observer by the <tt class="docutils literal">pb.Cacheable</tt> : these methods should have
names that start with <tt class="docutils literal">observe_</tt> , and match the
<tt class="docutils literal">callRemote</tt> invocations from the sender side just as the usual
<tt class="docutils literal">remote_*</tt> and <tt class="docutils literal">perspective_*</tt> methods match normal
<tt class="docutils literal">callRemote</tt> calls.</p>
<p>The first time a reference to the <tt class="docutils literal">pb.Cacheable</tt> object is
sent to any particular recipient, a sender-side Observer will be created for
it, and the <tt class="docutils literal">getStateToCacheAndObserveFor</tt> method will be called
to get the current state and register the Observer. The state which that
returns is sent to the remote end and turned into a local representation
using <tt class="docutils literal">setCopyableState</tt> just like <tt class="docutils literal">pb.RemoteCopy</tt> ,
described above (in fact it inherits from that class).</p>
<p>After that, your "setter" functions on the sender side should call
<tt class="docutils literal">callRemote</tt> on the Observer, which causes <tt class="docutils literal">observe_*</tt>
methods to run on the receiver, which are then supposed to update the
receiver-local (cached) state.</p>
<p>When the receiver stops following the cached object and the last
reference goes away, the <tt class="docutils literal">pb.RemoteCache</tt> object can be freed.
Just before it dies, it tells the sender side it no longer cares about the
original object. When <em>that</em> reference count goes to zero, the
Observer goes away and the <tt class="docutils literal">pb.Cacheable</tt> object can stop
announcing every change that takes place. The <cite>stoppedObserving &lt;twisted.spread.pb.Cacheable.stoppedObserving&gt;</cite> method is
used to tell the <tt class="docutils literal">pb.Cacheable</tt> that the Observer has gone
away.</p>
<p>With the <tt class="docutils literal">pb.Cacheable</tt> and <tt class="docutils literal">pb.RemoteCache</tt>
classes in place, bound together by a call to
<tt class="docutils literal">pb.setUnjellyableForClass</tt> , all that remains is to pass a
reference to your <tt class="docutils literal">pb.Cacheable</tt> over the wire to the remote end.
The corresponding <tt class="docutils literal">pb.RemoteCache</tt> object will automatically be
created, and the matching methods will be used to keep the receiver-side
slave object in sync with the sender-side master object.</p>
<div class="section" id="example">
<h3><a class="toc-backref" href="#id22">Example</a></h3>
<p>Here is a complete example, in which the <tt class="docutils literal">MasterDuckPond</tt> is
controlled by the sending side, and the <tt class="docutils literal">SlaveDuckPond</tt> is a
cache that tracks changes to the master:</p>
<p><cite>cache_classes.py &lt;listings/pb/cache_classes.py&gt;</cite></p>
<p><cite>cache_sender.py &lt;listings/pb/cache_sender.py&gt;</cite></p>
<p><cite>cache_receiver.py &lt;listings/pb/cache_receiver.py&gt;</cite></p>
<p>When run, this example emits the following:</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>twistd -n -y cache_receiver.py
<span class="go">[-] twisted.spread.pb.PBServerFactory starting on 8800</span>
<span class="go">[-] Starting factory &lt;twisted.spread.pb.PBServerFactory instance at</span>
<span class="go">0x40615acc&gt;</span>
<span class="go">[Broker,0,127.0.0.1]  cache - sitting, er, setting ducks</span>
<span class="go">[Broker,0,127.0.0.1] got pond: &lt;cache_classes.SlaveDuckPond instance at</span>
<span class="go">0x406eb5ec&gt;</span>
<span class="go">[Broker,0,127.0.0.1] [2] ducks:  ['one duck', 'two duck']</span>
<span class="go">[Broker,0,127.0.0.1]  cache - addDuck</span>
<span class="go">[Broker,0,127.0.0.1] [3] ducks:  ['one duck', 'two duck', 'ugly duckling']</span>
<span class="go">[Broker,0,127.0.0.1]  cache - removeDuck</span>
<span class="go">[Broker,0,127.0.0.1] [2] ducks:  ['two duck', 'ugly duckling']</span>
<span class="go">[Broker,0,127.0.0.1] dropping pond</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="gp">$ </span>./cache_sender.py
<span class="go">I have [2] ducks</span>
<span class="go">I have [3] ducks</span>
<span class="go">I have [2] ducks</span>
<span class="go">Main loop terminated.</span>
</pre></div>
<p>Points to notice:</p>
<ul>
<li><p class="first">There is one <tt class="docutils literal">Observer</tt> for each remote program that holds
an active reference. Multiple references inside the same program don't
matter: the serialization layer notices the duplicates and does the
appropriate reference counting <a class="footnote-reference" href="#id11" id="id5">[5]</a> .</p>
</li>
<li><p class="first">Multiple Observers need to be kept in a list, and all of them need to
be updated when something changes. By sending the initial state at the
same time as you add the observer to the list, in a single atomic action
that cannot be interrupted by a state change, you insure that you can send
the same status update to all the observers.</p>
</li>
<li><p class="first">The <tt class="docutils literal">observer.callRemote</tt> calls can still fail. If the
remote side has disconnected very recently and
<tt class="docutils literal">stoppedObserving</tt> has not yet been called, you may get a
<tt class="docutils literal">DeadReferenceError</tt> . It is a good idea to add an errback to
those <tt class="docutils literal">callRemote</tt> s to throw away such an error. This is a
useful idiom:</p>
<div class="highlight"><pre><span></span><span class="n">observer</span><span class="o">.</span><span class="n">callRemote</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span><span class="o">.</span><span class="n">addErrback</span><span class="p">(</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="kc">None</span><span class="p">)</span>
</pre></div>
</li>
</ul>
<!-- (XXX: verify that this is actually a concern) -->
<ul class="simple">
<li><tt class="docutils literal">getStateToCacheAndObserverFor</tt> must return some object
that represents the current state of the object. This may simply be the
object's <tt class="docutils literal">__dict__</tt> attribute. It is a good idea to remove the
<tt class="docutils literal">pb.Cacheable</tt> -specific members of it before sending it to the
remote end. The list of Observers, in particular, should be left out, to
avoid dizzying recursive Cacheable references. The mind boggles as to the
potential consequences of leaving in such an item.</li>
<li>A <tt class="docutils literal">perspective</tt> argument is available to
<tt class="docutils literal">getStateToCacheAndObserveFor</tt> , as well as
<tt class="docutils literal">stoppedObserving</tt> . I think the purpose of this is to allow
viewer-specific changes to the way the cache is updated. If all remote
viewers are supposed to see the same data, it can be ignored.</li>
</ul>
<!-- <p>XXX: understand, then explain use of varying cached state depending upon -->
<!-- perspective.</p> -->
</div>
<div class="section" id="id6">
<h3><a class="toc-backref" href="#id23">More Information</a></h3>
<ul class="simple">
<li>The best source for information comes from the docstrings
in <cite>twisted.spread.flavors</cite> ,
where <tt class="docutils literal">pb.Cacheable</tt> is implemented.</li>
<li>The <cite>spread.publish &lt;twisted.spread.publish&gt;</cite> module also
uses <tt class="docutils literal">Cacheable</tt> , and might be a source of further
information.</li>
</ul>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Note that, in this context, "unjelly"  is
a verb with the opposite meaning of "jelly" . The verb "to jelly"
means to serialize an object or data structure into a sequence of bytes (or
other primitive transmittable/storable representation), while "to unjelly"  means to unserialize the bytestream into a live object in the
receiver's memory space. "Unjellyable"  is a noun, (<em>not</em>  an
adjective), referring to the class that serves as a destination or
recipient of the unjellying process. "A is unjellyable into B"  means
that a serialized representation A (of some remote object) can be
unserialized into a local object of type B. It is these objects "B"
that are the "Unjellyable"  second argument of the
<tt class="docutils literal">setUnjellyableForClass</tt>  function.
In particular, "unjellyable"  does <em>not</em>  mean "cannot be jellied" . <cite>Unpersistable &lt;twisted.spread.jelly.Unpersistable&gt;</cite>  means "not persistable" , but "unjelly" , "unserialize" , and "unpickle"
mean to reverse the operations of "jellying" , "serializing" , and
"pickling" .</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><cite>pb.RemoteCopy &lt;twisted.spread.pb.RemoteCopy&gt;</cite>  is actually defined
in <cite>twisted.spread.flavors</cite> , but
<tt class="docutils literal">pb.RemoteCopy</tt>  is the preferred way to access it</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>Of course you could be clever and
add a hook to <tt class="docutils literal">__setattr__</tt> , along with magical change-announcing
subclasses of the usual builtin types, to detect changes that result from
normal "="  set operations. The semi-magical "property attributes"
that were introduced in Python 2.2 could be useful too. The result might be
hard to maintain or extend, though.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>This is actually a <cite>RemoteCacheObserver &lt;twisted.spread.pb.RemoteCacheObserver&gt;</cite> , but it isn't very
useful to subclass or modify, so simply treat it as a little demon that sits
in your <tt class="docutils literal">pb.Cacheable</tt>  class and helps you distribute change
notifications. The only useful thing to do with it is to run its
<tt class="docutils literal">callRemote</tt>  method, which acts just like a normal
<tt class="docutils literal">pb.Referenceable</tt> 's method of the same name.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td>This applies to
multiple references through the same <cite>Broker &lt;twisted.spread.pb.Broker&gt;</cite> . If you've managed to make multiple
TCP connections to the same program, you deserve whatever you get.</td></tr>
</tbody>
</table>

</div>
</div>

        </div>
        </div>
        </div>
<div class="sphinxsidebar">
<div class="sphinxsidebarwrapper">
<div class="toc" id="">
<p class="topic-title">Table Of Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#overview" id="id12">Overview</a></li>
<li><a class="reference internal" href="#motivation" id="id13">Motivation</a></li>
<li><a class="reference internal" href="#passing-objects" id="id14">Passing Objects</a><ul>
<li><a class="reference internal" href="#security-options" id="id15">Security Options</a></li>
<li><a class="reference internal" href="#what-class-to-use" id="id16">What class to use?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pb-copyable" id="id17">pb.Copyable</a><ul>
<li><a class="reference internal" href="#controlling-the-copied-state" id="id18">Controlling the Copied State</a></li>
<li><a class="reference internal" href="#things-to-watch-out-for" id="id19">Things To Watch Out For</a></li>
<li><a class="reference internal" href="#more-information" id="id20">More Information</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pb-cacheable" id="id21">pb.Cacheable</a><ul>
<li><a class="reference internal" href="#example" id="id22">Example</a></li>
<li><a class="reference internal" href="#id6" id="id23">More Information</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div>    </div>

    </section>

        <div id="footer"><hr>
                <div> </div>
                <p class="left2">
        Copyright 2021, Twisted Matrix Labs. Ver 21.2.0. Built on 2021-02-28.<br />
        Site design<br />
        By <a href="http://huw.ugbox.net/">huw.wilkins.</a>

                </p>
                <p class="right"></p>
        </div>


</body>
</html>