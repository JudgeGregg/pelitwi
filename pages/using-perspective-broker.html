<!DOCTYPE html>
<html lang="en">
<head>
          <title>Test Pelican - Using Perspective Broker</title>
        <meta charset="utf-8" />
        <meta name="generator" content="Pelican" />

        <meta name="Description" content="An event-driven networking engine written in Python and MIT licensed." />

        <link rel="stylesheet" type="text/css" href="https://judgegregg.github.io/pelitwi/theme/css/twistedtrac.css" />


</head>

<body>
        <div id="banner">
                <div id="top_grad"></div>
                <div id="tab">
                        <a href="https://twistedmatrix.com/trac/wiki">HOME</a>
                        <a href="https://twistedmatrix.com/trac/wiki/FrequentlyAskedQuestions">FAQ</a>
                        <a href="/">DOCS</a>
                        <a href="https://twistedmatrix.com/trac/wiki/Downloads">DOWNLOAD</a>
                </div>

                <div id="header">
                        <a id="logo" href="https://judgegregg.github.io/pelitwi/"><img src="https://judgegregg.github.io/pelitwi/theme/images/trac_banner.png" alt="Twisted" /></a>
                </div>
        </div>

<div id="mainnav" class="related">
	<ul>
		<li><a href="https://judgegregg.github.io/pelitwi">Twisted 21.2.0 documentation</a> Â»</li>
	</ul>
</div>
        <div id="ctxtnav" class="nav">
        </div>

    <section>

    <div class="document">
        <div class="documentwrapper">
        <div class="bodywrapper">
        <h1>Using Perspective Broker</h1>
        
        <div class="entry-content">
        <div class="section" id="basic-example">
<h2><a class="toc-backref" href="#id12">Basic Example</a></h2>
<p>The first example to look at is a complete (although somewhat trivial)
application. It uses <tt class="docutils literal">PBServerFactory()</tt> on the server side, and
<tt class="docutils literal">PBClientFactory()</tt> on the client side.</p>
<p><cite>pbsimple.py &lt;../examples/pbsimple.py&gt;</cite></p>
<p><cite>pbsimpleclient.py &lt;../examples/pbsimpleclient.py&gt;</cite></p>
<p>First we look at the server. This defines an Echoer class (derived from
<cite>pb.Root &lt;twisted.spread.pb.Root&gt;</cite> ), with a method called
<tt class="docutils literal">remote_echo()</tt> .
<cite>pb.Root &lt;twisted.spread.pb.Root&gt;</cite> objects (because of
their inheritance of
<cite>pb.Referenceable &lt;twisted.spread.pb.Referenceable&gt;</cite> , described
later) can define methods with names of the form <tt class="docutils literal">remote_*</tt> ; a
client which obtains a remote reference to that
<cite>pb.Root &lt;twisted.spread.pb.Root&gt;</cite> object will be able to
invoke those methods.</p>
<p>The <cite>pb.Root &lt;twisted.spread.pb.Root&gt;</cite> -ish object is
given to a <cite>pb.PBServerFactory &lt;twisted.spread.pb.PBServerFactory&gt;</cite> <tt class="docutils literal">()</tt> . This is a
<cite>Factory &lt;twisted.internet.protocol.Factory&gt;</cite> object like
any other: the <cite>Protocol &lt;twisted.internet.protocol.Protocol&gt;</cite> objects it creates for new
connections know how to speak the PB protocol. The object you give to
<tt class="docutils literal">pb.PBServerFactory()</tt> becomes the "root object" , which
simply makes it available for the client to retrieve. The client may only
request references to the objects you want to provide it: this helps you
implement your security model. Because it is so common to export just a
single object (and because a <tt class="docutils literal">remote_*</tt> method on that one can
return a reference to any other object you might want to give out), the
simplest example is one where the <cite>PBServerFactory &lt;twisted.spread.pb.PBServerFactory&gt;</cite> is given the root object, and
the client retrieves it.</p>
<p>The client side uses
<cite>pb.PBClientFactory &lt;twisted.spread.pb.PBClientFactory&gt;</cite> to make a
connection to a given port. This is a two-step process involving opening
a TCP connection to a given host and port and requesting the root object
using <tt class="docutils literal">.getRootObject()</tt> .</p>
<p>Because <tt class="docutils literal">.getRootObject()</tt> has to wait until a network
connection has been made and exchange some data, it may take a while,
so it returns a Deferred, to which the gotObject() callback is
attached. (See the documentation on <a class="reference external" href="https://judgegregg.github.io/pelitwi/pages/deferred-reference.html">Deferring Execution</a> for a complete explanation of <cite>Deferred &lt;twisted.internet.defer.Deferred&gt;</cite> s). If and when the
connection succeeds and a reference to the remote root object is
obtained, this callback is run. The first argument passed to the
callback is a remote reference to the distant root object.  (you can
give other arguments to the callback too, see the other parameters for
<tt class="docutils literal">.addCallback()</tt> and <tt class="docutils literal">.addCallbacks()</tt> ).</p>
<p>The callback does:</p>
<div class="highlight"><pre><span></span><span class="nb">object</span><span class="o">.</span><span class="n">callRemote</span><span class="p">(</span><span class="s2">"echo"</span><span class="p">,</span> <span class="s2">"hello network"</span><span class="p">)</span>
</pre></div>
<p>which causes the server's <tt class="docutils literal">.remote_echo()</tt> method to be invoked.
(running <tt class="docutils literal"><span class="pre">.callRemote("boom")</span></tt> would cause
<tt class="docutils literal">.remote_boom()</tt> to be run, etc). Again because of the delay
involved, <tt class="docutils literal">callRemote()</tt> returns a
<cite>Deferred &lt;twisted.internet.defer.Deferred&gt;</cite> . Assuming the
remote method was run without causing an exception (including an attempt to
invoke an unknown method), the callback attached to that
<cite>Deferred &lt;twisted.internet.defer.Deferred&gt;</cite> will be
invoked with any objects that were returned by the remote method call.</p>
<p>In this example, the server's <tt class="docutils literal">Echoer</tt> object has a method
invoked, <em>exactly</em> as if some code on the server side had done:</p>
<div class="highlight"><pre><span></span><span class="n">echoer_object</span><span class="o">.</span><span class="n">remote_echo</span><span class="p">(</span><span class="s2">"hello network"</span><span class="p">)</span>
</pre></div>
<p>and from the definition of <tt class="docutils literal">remote_echo()</tt> we see that this just
returns the same string it was given: "hello network" .</p>
<p>From the client's point of view, the remote call gets another <cite>Deferred &lt;twisted.internet.defer.Deferred&gt;</cite> object instead of
that string. <tt class="docutils literal">callRemote()</tt> <em>always</em> returns a <cite>Deferred &lt;twisted.internet.defer.Deferred&gt;</cite> . This is why PB is
described as a system for "translucent" remote method calls instead of "transparent" ones: you cannot pretend that the remote object is really
local. Trying to do so (as some other RPC mechanisms do, coughCORBAcough)
breaks down when faced with the asynchronous nature of the network. Using
Deferreds turns out to be a very clean way to deal with the whole thing.</p>
<p>The remote reference object (the one given to
<tt class="docutils literal">getRootObject()</tt> 's success callback) is an instance the <cite>RemoteReference &lt;twisted.spread.pb.RemoteReference&gt;</cite> class. This means
you can use it to invoke methods on the remote object that it refers to. Only
instances of <cite>RemoteReference &lt;twisted.spread.pb.RemoteReference&gt;</cite> are eligible for
<tt class="docutils literal">.callRemote()</tt> . The <cite>RemoteReference &lt;twisted.spread.pb.RemoteReference&gt;</cite> object is the one that lives
on the remote side (the client, in this case), not the local side (where the
actual object is defined).</p>
<p>In our example, the local object is that <tt class="docutils literal">Echoer()</tt> instance,
which inherits from <cite>pb.Root &lt;twisted.spread.pb.Root&gt;</cite> ,
which inherits from
<cite>pb.Referenceable &lt;twisted.spread.pb.Referenceable&gt;</cite> . It is that
<tt class="docutils literal">Referenceable</tt> class that makes the object eligible to be available
for remote method calls <a class="footnote-reference" href="#id6" id="id1">[1]</a> . If you have
an object that is Referenceable, then any client that manages to get a
reference to it can invoke any <tt class="docutils literal">remote_*</tt> methods they please.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The <em>only</em> thing they can do is invoke those
methods.  In particular, they cannot access attributes. From a security point
of view, you control what they can do by limiting what the <tt class="docutils literal">remote_*</tt> methods can do.</p>
<p>Also note: the other classes like
<cite>Referenceable &lt;twisted.spread.pb.Referenceable&gt;</cite> allow access to
other methods, in particular <tt class="docutils literal">perspective_*</tt> and <tt class="docutils literal">view_*</tt>
may be accessed.  Don't write local-only methods with these names, because then
remote callers will be able to do more than you intended.</p>
<p class="last">Also also note: the other classes like
<cite>pb.Copyable &lt;twisted.spread.pb.Copyable&gt;</cite> <em>do</em> allow
access to attributes, but you control which ones they can see.</p>
</div>
<p>You don't have to be a
<cite>pb.Root &lt;twisted.spread.pb.Root&gt;</cite> to be remotely callable,
but you do have to be
<cite>pb.Referenceable &lt;twisted.spread.pb.Referenceable&gt;</cite> .  (Objects that
inherit from <cite>pb.Referenceable &lt;twisted.spread.pb.Referenceable&gt;</cite>
but not from <cite>pb.Root &lt;twisted.spread.pb.Root&gt;</cite> can be
remotely called, but only
<cite>pb.Root &lt;twisted.spread.pb.Root&gt;</cite> -ish objects can be given
to the <cite>PBServerFactory &lt;twisted.spread.pb.PBServerFactory&gt;</cite> .)</p>
</div>
<div class="section" id="complete-example">
<h2><a class="toc-backref" href="#id13">Complete Example</a></h2>
<p>Here is an example client and server which uses <cite>pb.Referenceable &lt;twisted.spread.pb.Referenceable&gt;</cite> as a root object and as the
result of a remotely exposed method.  In each context, methods can be invoked
on the exposed <cite>Referenceable &lt;twisted.spread.pb.Referenceable&gt;</cite>
instance.  In this example, the initial root object has a method that returns a
reference to the second object.</p>
<p><cite>pb1server.py &lt;listings/pb/pb1server.py&gt;</cite></p>
<p><cite>pb1client.py &lt;listings/pb/pb1client.py&gt;</cite></p>
<p><cite>pb.PBClientFactory.getRootObject &lt;twisted.spread.pb.PBClientFactory.getRootObject&gt;</cite> will
handle all the details of waiting for the creation of a connection.
It returns a <cite>Deferred &lt;twisted.internet.defer.Deferred&gt;</cite> , which will have its
callback called when the reactor connects to the remote server and
<cite>pb.PBClientFactory &lt;twisted.spread.pb.PBClientFactory&gt;</cite> gets the
root, and have its <tt class="docutils literal">errback</tt> called when the
object-connection fails for any reason, whether it was host lookup
failure, connection refusal, or some server-side error.</p>
<p>The root object has a method called <tt class="docutils literal">remote_getTwo</tt> , which
returns the <tt class="docutils literal">Two()</tt> instance. On the client end, the callback gets
a <cite>RemoteReference &lt;twisted.spread.pb.RemoteReference&gt;</cite> to that
instance. The client can then invoke two's <tt class="docutils literal">.remote_three()</tt>
method.</p>
<p><cite>RemoteReference &lt;twisted.spread.pb.RemoteReference&gt;</cite>
objects have one method which is their purpose for being: <tt class="docutils literal">callRemote</tt> .  This method allows you to call a
remote method on the object being referred to by the Reference.  <cite>RemoteReference.callRemote &lt;twisted.spread.pb.RemoteReference.callRemote&gt;</cite> , like <cite>pb.PBClientFactory.getRootObject &lt;twisted.spread.pb.PBClientFactory.getRootObject&gt;</cite> , returns
a <cite>Deferred &lt;twisted.internet.defer.Deferred&gt;</cite> .
When a response to the method-call being sent arrives, the <cite>Deferred &lt;twisted.internet.defer.Deferred&gt;</cite> 's <tt class="docutils literal">callback</tt> or <tt class="docutils literal">errback</tt>
will be made, depending on whether an error occurred in processing the
method call.</p>
<p>You can use this technique to provide access to arbitrary sets of objects.
Just remember that any object that might get passed "over the wire" must
inherit from <cite>Referenceable &lt;twisted.spread.pb.Referenceable&gt;</cite>
(or one of the other flavors). If you try to pass a non-Referenceable object
(say, by returning one from a <tt class="docutils literal">remote_*</tt> method), you'll get an
<cite>InsecureJelly &lt;twisted.spread.jelly.InsecureJelly&gt;</cite>
exception <a class="footnote-reference" href="#id7" id="id2">[2]</a> .</p>
</div>
<div class="section" id="references-can-come-back-to-you">
<h2><a class="toc-backref" href="#id14">References can come back to you</a></h2>
<p>If your server gives a reference to a client, and then that client gives
the reference back to the server, the server will wind up with the same
object it gave out originally. The serialization layer watches for returning
reference identifiers and turns them into actual objects. You need to stay
aware of where the object lives: if it is on your side, you do actual method
calls. If it is on the other side, you do
<tt class="docutils literal">.callRemote()</tt> <a class="footnote-reference" href="#id8" id="id3">[3]</a> .</p>
<p><cite>pb2server.py &lt;listings/pb/pb2server.py&gt;</cite></p>
<p><cite>pb2client.py &lt;listings/pb/pb2client.py&gt;</cite></p>
<p>The server gives a <tt class="docutils literal">Two()</tt> instance to the client, who then
returns the reference back to the server. The server compares the "two"
given with the "two" received and shows that they are the same, and that
both are real objects instead of remote references.</p>
<p>A few other techniques are demonstrated in <tt class="docutils literal">pb2client.py</tt> . One
is that the callbacks are added with <tt class="docutils literal">.addCallback</tt> instead
of <tt class="docutils literal">.addCallbacks</tt> . As you can tell from the <a class="reference external" href="https://judgegregg.github.io/pelitwi/pages/deferred-reference.html">Deferred</a> documentation, <tt class="docutils literal">.addCallback</tt> is a
simplified form which only adds a success callback. The other is that to
keep track of state from one callback to the next (the remote reference to
the main One() object), we create a simple class, store the reference in an
instance thereof, and point the callbacks at a sequence of bound methods.
This is a convenient way to encapsulate a state machine. Each response kicks
off the next method, and any data that needs to be carried from one state to
the next can simply be saved as an attribute of the object.</p>
<p>Remember that the client can give you back any remote reference you've
given them. Don't base your zillion-dollar stock-trading clearinghouse
server on the idea that you trust the client to give you back the right
reference. The security model inherent in PB means that they can <em>only</em>
give you back a reference that you've given them for the current connection
(not one you've given to someone else instead, nor one you gave them last
time before the TCP session went down, nor one you haven't yet given to the
client), but just like with URLs and HTTP cookies, the particular reference
they give you is entirely under their control.</p>
</div>
<div class="section" id="references-to-client-side-objects">
<h2><a class="toc-backref" href="#id15">References to client-side objects</a></h2>
<p>Anything that's Referenceable can get passed across the wire, <em>in either direction</em> . The "client" can give a reference to the
"server" , and then the server can use .callRemote() to invoke methods on
the client end. This fuzzes the distinction between "client" and
"server" : the only real difference is who initiates the original TCP
connection; after that it's all symmetric.</p>
<p><cite>pb3server.py &lt;listings/pb/pb3server.py&gt;</cite></p>
<p><cite>pb3client.py &lt;listings/pb/pb3client.py&gt;</cite></p>
<p>In this example, the client gives a reference to its own object to the
server. The server then invokes a remote method on the client-side
object.</p>
</div>
<div class="section" id="raising-remote-exceptions">
<h2><a class="toc-backref" href="#id16">Raising Remote Exceptions</a></h2>
<p>Everything so far has covered what happens when things go right. What
about when they go wrong? The Python Way is to raise an exception of some
sort. The Twisted Way is the same.</p>
<p>The only special thing you do is to define your <tt class="docutils literal">Exception</tt>
subclass by deriving it from <cite>pb.Error &lt;twisted.spread.pb.Error&gt;</cite> . When any remotely-invokable method
(like <tt class="docutils literal">remote_*</tt> or <tt class="docutils literal">perspective_*</tt> ) raises a
<tt class="docutils literal">pb.Error</tt> -derived exception, a serialized form of that Exception
object will be sent back over the wire <a class="footnote-reference" href="#id9" id="id4">[4]</a> . The other side (which
did <tt class="docutils literal">callRemote</tt> ) will have the "<tt class="docutils literal">errback</tt>"
callback run with a <cite>Failure &lt;twisted.python.failure.Failure&gt;</cite> object that contains a copy of
the exception object. This <tt class="docutils literal">Failure</tt> object can be queried to
retrieve the error message and a stack traceback.</p>
<p><cite>Failure &lt;twisted.python.failure.Failure&gt;</cite> is a
special class, defined in <tt class="docutils literal">twisted/python/failure.py</tt> , created to
make it easier to handle asynchronous exceptions. Just as exception handlers
can be nested, <tt class="docutils literal">errback</tt> functions can be chained. If one errback
can't handle the particular type of failure, it can be "passed along" to a
errback handler further down the chain.</p>
<p>For simple purposes, think of the <tt class="docutils literal">Failure</tt> as just a container
for remotely-thrown <tt class="docutils literal">Exception</tt> objects. To extract the string that
was put into the exception, use its <tt class="docutils literal">.getErrorMessage()</tt> method.
To get the type of the exception (as a string), look at its
<tt class="docutils literal">.type</tt> attribute. The stack traceback is available too. The
intent is to let the errback function get just as much information about the
exception as Python's normal <tt class="docutils literal">try:</tt> clauses do, even though the
exception occurred in somebody else's memory space at some unknown time in
the past.</p>
<p><cite>exc_server.py &lt;listings/pb/exc_server.py&gt;</cite></p>
<p><cite>exc_client.py &lt;listings/pb/exc_client.py&gt;</cite></p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>./exc_client.py
<span class="go">got remote Exception</span>
<span class="go"> .__class__ = twisted.spread.pb.CopiedFailure</span>
<span class="go"> .getErrorMessage() = fall down go boom</span>
<span class="go"> .type = __main__.MyError</span>
<span class="go">Main loop terminated.</span>
</pre></div>
<p>Oh, and what happens if you raise some other kind of exception? Something
that <em>isn't</em> subclassed from <tt class="docutils literal">pb.Error</tt> ? Well, those are
called "unexpected exceptions" , which make Twisted think that something
has <em>really</em> gone wrong. These will raise an exception on the
<em>server</em> side. This won't break the connection (the exception is
trapped, just like most exceptions that occur in response to network
traffic), but it will print out an unsightly stack trace on the server's
stderr with a message that says "Peer Will Receive PB Traceback" , just
as if the exception had happened outside a remotely-invokable method. (This
message will go the current log target, if <cite>log.startLogging &lt;twisted.python.log.startLogging&gt;</cite> was used to redirect it). The
client will get the same <tt class="docutils literal">Failure</tt> object in either case, but
subclassing your exception from <tt class="docutils literal">pb.Error</tt> is the way to tell
Twisted that you expect this sort of exception, and that it is ok to just
let the client handle it instead of also asking the server to complain. Look
at <tt class="docutils literal">exc_client.py</tt> and change it to invoke <tt class="docutils literal">broken2()</tt>
instead of <tt class="docutils literal">broken()</tt> to see the change in the server's
behavior.</p>
<p>If you don't add an <tt class="docutils literal">errback</tt> function to the <cite>Deferred &lt;twisted.internet.defer.Deferred&gt;</cite> , then a remote
exception will still send a <tt class="docutils literal">Failure</tt> object back over, but it
will get lodged in the <tt class="docutils literal">Deferred</tt> with nowhere to go. When that
<tt class="docutils literal">Deferred</tt> finally goes out of scope, the side that did
<tt class="docutils literal">callRemote</tt> will emit a message about an "Unhandled error in Deferred" , along with an ugly stack trace. It can't raise an exception at
that point (after all, the <tt class="docutils literal">callRemote</tt> that triggered the
problem is long gone), but it will emit a traceback. So be a good programmer
and <em>always</em> add <tt class="docutils literal">errback</tt> handlers, even if they are just
calls to <cite>log.err &lt;twisted.python.log.err&gt;</cite> .</p>
</div>
<div class="section" id="try-except-blocks-and-failure-trap-twisted-python-failure-failure-trap">
<h2><a class="toc-backref" href="#id17">Try/Except blocks and <cite>Failure.trap &lt;twisted.python.failure.Failure.trap&gt;</cite></a></h2>
<p>To implement the equivalent of the Python try/except blocks (which can
trap particular kinds of exceptions and pass others "up" to
higher-level <tt class="docutils literal">try/except</tt> blocks), you can use the
<tt class="docutils literal">.trap()</tt> method in conjunction with multiple
<tt class="docutils literal">errback</tt> handlers on the <tt class="docutils literal">Deferred</tt> . Re-raising an
exception in an <tt class="docutils literal">errback</tt> handler serves to pass that new
exception to the next handler in the chain. The <tt class="docutils literal">trap</tt> method is
given a list of exceptions to look for, and will re-raise anything that
isn't on the list. Instead of passing unhandled exceptions "up" to an
enclosing <tt class="docutils literal">try</tt> block, this has the effect of passing the
exception "off" to later <tt class="docutils literal">errback</tt> handlers on the same <tt class="docutils literal">Deferred</tt> . The <tt class="docutils literal">trap</tt> calls are used in chained
errbacks to test for each kind of exception in sequence.</p>
<p><cite>trap_server.py &lt;listings/pb/trap_server.py&gt;</cite></p>
<p><cite>trap_client.py &lt;listings/pb/trap_client.py&gt;</cite></p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>./trap_client.py
<span class="go">callOne: call with safe object</span>
<span class="go"> method successful, response: response</span>
<span class="go">callTwo: call with dangerous object</span>
<span class="go"> InsecureJelly: you tried to send something unsafe to them</span>
<span class="go">callThree: call that raises remote exception</span>
<span class="go"> remote raised a MyException</span>
<span class="go">telling them to shut down</span>
<span class="go">callFour: call on stale reference</span>
<span class="go"> stale reference: the client disconnected or crashed</span>
</pre></div>
<p>In this example, <tt class="docutils literal">callTwo</tt> tries to send an instance of a
locally-defined class through <tt class="docutils literal">callRemote</tt> . The default security
model implemented by <cite>jelly &lt;twisted.spread.jelly&gt;</cite>
on the remote end will not allow unknown classes to be unserialized (i.e.
taken off the wire as a stream of bytes and turned back into an object: a
living, breathing instance of some class): one reason is that it does not
know which local class ought to be used to create an instance that
corresponds to the remote object <a class="footnote-reference" href="#id10" id="id5">[5]</a> .</p>
<p>The receiving end of the connection gets to decide what to accept and what
to reject. It indicates its disapproval by raising a <cite>jelly.InsecureJelly &lt;twisted.spread.jelly.InsecureJelly&gt;</cite> exception. Because it occurs
at the remote end, the exception is returned to the caller asynchronously,
so an <tt class="docutils literal">errback</tt> handler for the associated <tt class="docutils literal">Deferred</tt>
is run. That errback receives a <tt class="docutils literal">Failure</tt> which wraps the
<tt class="docutils literal">InsecureJelly</tt> .</p>
<p>Remember that <tt class="docutils literal">trap</tt> re-raises exceptions that it wasn't asked
to look for. You can only check for one set of exceptions per errback
handler: all others must be checked in a subsequent handler.
<tt class="docutils literal">check_MyException</tt> shows how multiple kinds of exceptions can be
checked in a single errback: give a list of exception types to
<tt class="docutils literal">trap</tt> , and it will return the matching member. In this case, the
kinds of exceptions we are checking for (<tt class="docutils literal">MyException</tt> and
<tt class="docutils literal">MyOtherException</tt> ) may be raised by the remote end: they inherit
from <cite>pb.Error &lt;twisted.spread.pb.Error&gt;</cite> .</p>
<p>The handler can return <tt class="docutils literal">None</tt> to terminate processing of the
errback chain (to be precise, it switches to the callback that follows the
errback; if there is no callback then processing terminates). It is a good
idea to put an errback that will catch everything (no <tt class="docutils literal">trap</tt>
tests, no possible chance of raising more exceptions, always returns
<tt class="docutils literal">None</tt> ) at the end of the chain. Just as with regular <tt class="docutils literal">try: except:</tt> handlers, you need to think carefully about ways in which
your errback handlers could themselves raise exceptions. The extra
importance in an asynchronous environment is that an exception that falls
off the end of the <tt class="docutils literal">Deferred</tt> will not be signalled until that
<tt class="docutils literal">Deferred</tt> goes out of scope, and at that point may only cause a
log message (which could even be thrown away if <cite>log.startLogging &lt;twisted.python.log.startLogging&gt;</cite> is not used to point it at
stdout or a log file). In contrast, a synchronous exception that is not
handled by any other <tt class="docutils literal">except:</tt> block will very visibly terminate
the program immediately with a noisy stack trace.</p>
<p><tt class="docutils literal">callFour</tt> shows another kind of exception that can occur
while using <tt class="docutils literal">callRemote</tt> : <cite>pb.DeadReferenceError &lt;twisted.spread.pb.DeadReferenceError&gt;</cite> . This one occurs when the
remote end has disconnected or crashed, leaving the local side with a stale
reference. This kind of exception happens to be reported right away (XXX: is
this guaranteed? probably not), so must be caught in a traditional
synchronous <tt class="docutils literal">try: except pb.DeadReferenceError</tt> block.</p>
<p>Yet another kind that can occur is a <cite>pb.PBConnectionLost &lt;twisted.spread.pb.PBConnectionLost&gt;</cite> exception. This occurs
(asynchronously) if the connection was lost while you were waiting for a <tt class="docutils literal">callRemote</tt> call to complete. When the line goes dead, all
pending requests are terminated with this exception. Note that you have no
way of knowing whether the request made it to the other end or not, nor how
far along in processing it they had managed before the connection was
lost. XXX: explain transaction semantics, find a decent reference.</p>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>There are a few other classes
that can bestow this ability, but pb.Referenceable is the easiest to
understand; see 'flavors' below for details on the others.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>This can be overridden, by subclassing one of
the Serializable flavors and defining custom serialization code for your
class. See <a class="reference external" href="https://judgegregg.github.io/pelitwi/pages/pb-copyable-passing-complex-types.html">Passing Complex Types</a>  for
details.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>The binary nature of this
local vs. remote scheme works because you cannot give RemoteReferences to a
third party. If you could, then your object A could go to B, B could give it to
C, C might give it back to you, and you would be hard pressed to tell if the
object lived in C's memory space, in B's, or if it was really your own object,
tarnished and sullied after being handed down like a really ugly picture that
your great aunt owned and which nobody wants but which nobody can bear to throw
out. Ok, not really like that, but you get the idea.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>To be precise,
the Failure will be sent if <em>any</em>  exception is raised, not just
pb.Error-derived ones. But the server will print ugly error messages if you
raise ones that aren't derived from pb.Error.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td><p class="first">The naive approach
of simply doing <tt class="docutils literal">import SomeClass</tt> to match a remote caller who
claims to have an object of type "SomeClass" could have nasty consequences
for some modules that do significant operations in their <tt class="docutils literal">__init__</tt>
methods (think <tt class="docutils literal"><span class="pre">telnetlib.Telnet(host='localhost',</span> <span class="pre">port='chargen')</span></tt> ,
or even more powerful classes that you have available in your server program).
Allowing a remote entity to create arbitrary classes in your namespace is
nearly equivalent to allowing them to run arbitrary code.</p>
<p class="last">The <cite>InsecureJelly &lt;twisted.spread.jelly.InsecureJelly&gt;</cite>
exception arises because the class being sent over the wire has not been
registered with the serialization layer (known as <cite>jelly &lt;twisted.spread.jelly&gt;</cite> ). The easiest way to make it possible to
copy entire class instances over the wire is to have them inherit from <cite>pb.Copyable &lt;twisted.spread.pb.Copyable&gt;</cite> , and then to use
<tt class="docutils literal">setUnjellyableForClass(remoteClass, localClass)</tt> on the
receiving side. See <a class="reference external" href="https://judgegregg.github.io/pelitwi/pages/pb-copyable-passing-complex-types.html">Passing Complex Types</a>
for an example.</p>
</td></tr>
</tbody>
</table>

</div>

        </div>
        </div>
        </div>
<div class="sphinxsidebar">
<div class="sphinxsidebarwrapper">
<div class="toc" id="">
<p class="topic-title">Table Of Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#basic-example" id="id12">Basic Example</a></li>
<li><a class="reference internal" href="#complete-example" id="id13">Complete Example</a></li>
<li><a class="reference internal" href="#references-can-come-back-to-you" id="id14">References can come back to you</a></li>
<li><a class="reference internal" href="#references-to-client-side-objects" id="id15">References to client-side objects</a></li>
<li><a class="reference internal" href="#raising-remote-exceptions" id="id16">Raising Remote Exceptions</a></li>
<li><a class="reference internal" href="#try-except-blocks-and-failure-trap-twisted-python-failure-failure-trap" id="id17">Try/Except blocks and <cite>Failure.trap &lt;twisted.python.failure.Failure.trap&gt;</cite></a></li>
</ul>
</div>
</div>
</div>    </div>

    </section>

        <div id="footer"><hr>
                <div> </div>
                <p class="left2">
        Copyright 2021, Twisted Matrix Labs. Ver 21.2.0. Built on 2021-02-28.<br />
        Site design<br />
        By <a href="http://huw.ugbox.net/">huw.wilkins.</a>

                </p>
                <p class="right"></p>
        </div>


</body>
</html>