<!DOCTYPE html>
<html lang="en">
<head>
          <title>Test Pelican - Components: Interfaces and Adapters</title>
        <meta charset="utf-8" />
        <meta name="generator" content="Pelican" />

        <meta name="Description" content="An event-driven networking engine written in Python and MIT licensed." />

        <link rel="stylesheet" type="text/css" href="https://judgegregg.github.io/pelitwi/theme/css/twistedtrac.css" />


</head>

<body>
        <div id="banner">
                <div id="top_grad"></div>
                <div id="tab">
                        <a href="https://twistedmatrix.com/trac/wiki">HOME</a>
                        <a href="https://twistedmatrix.com/trac/wiki/FrequentlyAskedQuestions">FAQ</a>
                        <a href="/">DOCS</a>
                        <a href="https://twistedmatrix.com/trac/wiki/Downloads">DOWNLOAD</a>
                </div>

                <div id="header">
                        <a id="logo" href="https://judgegregg.github.io/pelitwi/"><img src="https://judgegregg.github.io/pelitwi/theme/images/trac_banner.png" alt="Twisted" /></a>
                </div>
        </div>

<div id="mainnav" class="related">
	<ul>
		<li><a href="https://judgegregg.github.io/pelitwi">Twisted 21.2.0 documentation</a> Â»</li>
	</ul>
</div>
        <div id="ctxtnav" class="nav">
        </div>

    <section>

    <div class="document">
        <div class="documentwrapper">
        <div class="bodywrapper">
        <h1>Components: Interfaces and Adapters</h1>
        
        <div class="entry-content">
        <p>Object oriented programming languages allow programmers to reuse portions of existing code by creating new "classes" of objects which subclass another class.
When a class subclasses another, it is said to <em>inherit</em> all of its behaviour.
The subclass can then "override" and "extend" the behavior provided to it by the superclass.
Inheritance is very useful in many situations, but because it is so convenient to use, often becomes abused in large software systems, especially when multiple inheritance is involved.
One solution is to use <em>delegation</em> instead of "inheritance" where appropriate.
Delegation is simply the act of asking <em>another</em> object to perform a task for an object.
To support this design pattern, which is often referred to as the <em>components</em> pattern because it involves many small interacting components, <em>interfaces</em> and <em>adapters</em> were created by the Zope 3 team.</p>
<p>"Interfaces" are simply markers which objects can use to say "I implement this interface".
Other objects may then make requests like "Please give me an object which implements interface X for object type Y".
Objects which implement an interface for another object type are called "adapters".</p>
<p>The superclass-subclass relationship is said to be an <em>is-a</em> relationship.
When designing object hierarchies, object modellers use subclassing when they can say that the subclass <em>is</em> the same class as the superclass.
For example:</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Shape</span><span class="p">:</span>
    <span class="n">sideLength</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">def</span> <span class="nf">getSideLength</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sideLength</span>

    <span class="k">def</span> <span class="nf">setSideLength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sideLength</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sideLength</span> <span class="o">=</span> <span class="n">sideLength</span>

    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">"Subclasses must implement area"</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Triangle</span><span class="p">(</span><span class="n">Shape</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sideLength</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sideLength</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

<span class="k">class</span> <span class="nc">Square</span><span class="p">(</span><span class="n">Shape</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sideLength</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sideLength</span>
</pre></div>
<p>In the above example, a Triangle <em>is-a</em> Shape, so it subclasses Shape, and a Square <em>is-a</em> Shape, so it also subclasses Shape.</p>
<p>However, subclassing can get complicated, especially when Multiple Inheritance enters the picture.
Multiple Inheritance allows a class to inherit from more than one base class.
Software which relies heavily on inheritance often ends up having both very wide and very deep inheritance trees, meaning that one class inherits from many superclasses spread throughout the system.
Since subclassing with Multiple Inheritance means <em>implementation inheritance</em>, locating a method's actual implementation and ensuring the correct method is actually being invoked becomes a challenge.
For example:</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Area</span><span class="p">:</span>
    <span class="n">sideLength</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">def</span> <span class="nf">getSideLength</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sideLength</span>

    <span class="k">def</span> <span class="nf">setSideLength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sideLength</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sideLength</span> <span class="o">=</span> <span class="n">sideLength</span>

    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">"Subclasses must implement area"</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Color</span><span class="p">:</span>
    <span class="n">color</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">def</span> <span class="nf">setColor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">color</span>

    <span class="k">def</span> <span class="nf">getColor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span>

<span class="k">class</span> <span class="nc">Square</span><span class="p">(</span><span class="n">Area</span><span class="p">,</span> <span class="n">Color</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sideLength</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sideLength</span>
</pre></div>
<p>The reason programmers like using implementation inheritance is because it makes code easier to read since the implementation details of Area are in a separate place than the implementation details of Color.
This is nice, because conceivably an object could have a color but not an area, or an area but not a color.
The problem, though, is that Square is not really an Area or a Color, but has an area and color.
Thus, we should really be using another object oriented technique called <em>composition</em>, which relies on delegation rather than inheritance to break code into small reusable chunks.
Let us continue with the Multiple Inheritance example, though, because it is often used in practice.</p>
<p>What if both the Color and the Area base class defined the same method, perhaps <tt class="docutils literal">calculate</tt>?
Where would the implementation come from?
The implementation that is located for <tt class="docutils literal"><span class="pre">Square().calculate()</span></tt> depends on the method resolution order, or MRO, and can change when programmers change seemingly unrelated things by refactoring classes in other parts of the system, causing obscure bugs.
Our first thought might be to change the calculate method name to avoid name clashes, to perhaps <tt class="docutils literal">calculateArea</tt> and <tt class="docutils literal">calculateColor</tt>.
While explicit, this change could potentially require a large number of changes throughout a system, and is error-prone, especially when attempting to integrate two systems which you didn't write.</p>
<p>Let's imagine another example. We have an electric appliance, say a hair dryer.
The hair dryer is American voltage.
We have two electric sockets, one of them an American 120 Volt socket, and one of them a United Kingdom 240 Volt socket.
If we plug the hair dryer into the 240 Volt socket, it is going to expect 120 Volt current and errors will result.
Going back and changing the hair dryer to support both <tt class="docutils literal">plug120Volt</tt> and <tt class="docutils literal">plug240Volt</tt> methods would be tedious, and what if we decided we needed to plug the hair dryer into yet another type of socket?
For example:</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">HairDryer</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">plug</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">socket</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">socket</span><span class="o">.</span><span class="n">voltage</span><span class="p">()</span> <span class="o">==</span> <span class="mi">120</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">"I was plugged in properly and am operating."</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">"I was plugged in improperly and "</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">"now you have no hair dryer any more."</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">AmericanSocket</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">voltage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">120</span>

<span class="k">class</span> <span class="nc">UKSocket</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">voltage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">240</span>
</pre></div>
<p>Given these classes, the following operations can be performed:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hd</span> <span class="o">=</span> <span class="n">HairDryer</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">am</span> <span class="o">=</span> <span class="n">AmericanSocket</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hd</span><span class="o">.</span><span class="n">plug</span><span class="p">(</span><span class="n">am</span><span class="p">)</span>
<span class="go">I was plugged in properly and am operating.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uk</span> <span class="o">=</span> <span class="n">UKSocket</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hd</span><span class="o">.</span><span class="n">plug</span><span class="p">(</span><span class="n">uk</span><span class="p">)</span>
<span class="go">I was plugged in improperly and</span>
<span class="go">now you have no hair dryer any more.</span>
</pre></div>
<p>We are going to attempt to solve this problem by writing an Adapter for the <tt class="docutils literal">UKSocket</tt> which converts the voltage for use with an American hair dryer.
An Adapter is a class which is constructed with one and only one argument, the "adaptee" or "original" object.
In this example, we will show all code involved for clarity:</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">AdaptToAmericanSocket</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">original</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">original</span> <span class="o">=</span> <span class="n">original</span>

    <span class="k">def</span> <span class="nf">voltage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">original</span><span class="o">.</span><span class="n">voltage</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span>
</pre></div>
<p>Now, we can use it as so:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hd</span> <span class="o">=</span> <span class="n">HairDryer</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uk</span> <span class="o">=</span> <span class="n">UKSocket</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adapted</span> <span class="o">=</span> <span class="n">AdaptToAmericanSocket</span><span class="p">(</span><span class="n">uk</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hd</span><span class="o">.</span><span class="n">plug</span><span class="p">(</span><span class="n">adapted</span><span class="p">)</span>
<span class="go">I was plugged in properly and am operating.</span>
</pre></div>
<p>So, as you can see, an adapter can 'override' the original implementation.
It can also 'extend' the interface of the original object by providing methods the original object did not have.
Note that an Adapter must explicitly delegate any method calls it does not wish to modify to the original, otherwise the Adapter cannot be used in places where the original is expected.
Usually this is not a problem, as an Adapter is created to conform an object to a particular interface and then discarded.</p>
<div class="section" id="interfaces-and-components-in-twisted-code">
<h2><a class="toc-backref" href="#id1">Interfaces and Components in Twisted code</a></h2>
<p>Adapters are a useful way of using multiple classes to factor code into discrete chunks.
However, they are not very interesting without some more infrastructure.
If each piece of code which wished to use an adapted object had to explicitly construct the adapter itself, the coupling between components would be too tight.
We would like to achieve "loose coupling", and this is where <cite>twisted.python.components</cite> comes in.</p>
<p>First, we need to discuss Interfaces in more detail.
As we mentioned earlier, an Interface is nothing more than a class which is used as a marker.
Interfaces should be subclasses of <tt class="docutils literal">zope.interface.Interface</tt>, and have a very odd look to python programmers not used to them:</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">zope.interface</span> <span class="kn">import</span> <span class="n">Interface</span>

<span class="k">class</span> <span class="nc">IAmericanSocket</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">voltage</span><span class="p">():</span>
      <span class="sd">"""</span>
<span class="sd">      Return the voltage produced by this socket object, as an integer.</span>
<span class="sd">      """</span>
</pre></div>
<p>Notice how it looks just like a regular class definition, other than inheriting from <tt class="docutils literal">Interface</tt>?
However, the method definitions inside the class block do not have any method body!
Since Python does not have any native language-level support for Interfaces like Java does, this is what distinguishes an Interface definition from a Class.</p>
<p>Now that we have a defined Interface, we can talk about objects using terms like this:
"The <tt class="docutils literal">AmericanSocket</tt> class implements the <tt class="docutils literal">IAmericanSocket</tt> interface" and "Please give me an object which adapts <tt class="docutils literal">UKSocket</tt> to the <tt class="docutils literal">IAmericanSocket</tt> interface".
We can make <em>declarations</em> about what interfaces a certain class implements, and we can request adapters which implement a certain interface for a specific class.</p>
<p>Let's look at how we declare that a class implements an interface:</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">zope.interface</span> <span class="kn">import</span> <span class="n">implementer</span>

<span class="nd">@implementer</span><span class="p">(</span><span class="n">IAmericanSocket</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">AmericanSocket</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">voltage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">120</span>
</pre></div>
<p>So, to declare that a class implements an interface, we simply decorate it with <tt class="docutils literal">zope.interface.implementer</tt>.</p>
<p>Now, let's say we want to rewrite the <tt class="docutils literal">AdaptToAmericanSocket</tt> class as a real adapter.
In this case we also specify it as implementing <tt class="docutils literal">IAmericanSocket</tt>:</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">zope.interface</span> <span class="kn">import</span> <span class="n">implementer</span>

<span class="nd">@implementer</span><span class="p">(</span><span class="n">IAmericanSocket</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">AdaptToAmericanSocket</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">original</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Pass the original UKSocket object as original</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">original</span> <span class="o">=</span> <span class="n">original</span>

    <span class="k">def</span> <span class="nf">voltage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">original</span><span class="o">.</span><span class="n">voltage</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span>
</pre></div>
<p>Notice how we placed the implements declaration on this adapter class.
So far, we have not achieved anything by using components other than requiring us to type more.
In order for components to be useful, we must use the <em>component registry</em>.
Since <tt class="docutils literal">AdaptToAmericanSocket</tt> implements <tt class="docutils literal">IAmericanSocket</tt> and regulates the voltage of a <tt class="docutils literal">UKSocket</tt> object, we can register <tt class="docutils literal">AdaptToAmericanSocket</tt> as an <tt class="docutils literal">IAmericanSocket</tt> adapter for the <tt class="docutils literal">UKSocket</tt> class.
It is easier to see how this is done in code than to describe it:</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">zope.interface</span> <span class="kn">import</span> <span class="n">Interface</span><span class="p">,</span> <span class="n">implementer</span>
<span class="kn">from</span> <span class="nn">twisted.python</span> <span class="kn">import</span> <span class="n">components</span>

<span class="k">class</span> <span class="nc">IAmericanSocket</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">voltage</span><span class="p">():</span>
      <span class="sd">"""</span>
<span class="sd">      Return the voltage produced by this socket object, as an integer.</span>
<span class="sd">      """</span>

<span class="nd">@implementer</span><span class="p">(</span><span class="n">IAmericanSocket</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">AmericanSocket</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">voltage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">120</span>

<span class="k">class</span> <span class="nc">UKSocket</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">voltage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">240</span>

<span class="nd">@implementer</span><span class="p">(</span><span class="n">IAmericanSocket</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">AdaptToAmericanSocket</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">original</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">original</span> <span class="o">=</span> <span class="n">original</span>

    <span class="k">def</span> <span class="nf">voltage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">original</span><span class="o">.</span><span class="n">voltage</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span>

<span class="n">components</span><span class="o">.</span><span class="n">registerAdapter</span><span class="p">(</span>
    <span class="n">AdaptToAmericanSocket</span><span class="p">,</span>
    <span class="n">UKSocket</span><span class="p">,</span>
    <span class="n">IAmericanSocket</span><span class="p">)</span>
</pre></div>
<p>Now, if we run this script in the interactive interpreter, we can discover a little more about how to use components.
The first thing we can do is discover whether an object implements an interface or not:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">IAmericanSocket</span><span class="o">.</span><span class="n">implementedBy</span><span class="p">(</span><span class="n">AmericanSocket</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IAmericanSocket</span><span class="o">.</span><span class="n">implementedBy</span><span class="p">(</span><span class="n">UKSocket</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">am</span> <span class="o">=</span> <span class="n">AmericanSocket</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uk</span> <span class="o">=</span> <span class="n">UKSocket</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IAmericanSocket</span><span class="o">.</span><span class="n">providedBy</span><span class="p">(</span><span class="n">am</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IAmericanSocket</span><span class="o">.</span><span class="n">providedBy</span><span class="p">(</span><span class="n">uk</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
<p>As you can see, the <tt class="docutils literal">AmericanSocket</tt> instance claims to implement <tt class="docutils literal">IAmericanSocket</tt>, but the <tt class="docutils literal">UKSocket</tt> does not.
If we wanted to use the <tt class="docutils literal">HairDryer</tt> with the <tt class="docutils literal">AmericanSocket</tt>, we could know that it would be safe to do so by checking whether it implements <tt class="docutils literal">IAmericanSocket</tt>.
However, if we decide we want to use <tt class="docutils literal">HairDryer</tt> with a <tt class="docutils literal">UKSocket</tt> instance, we must <em>adapt</em> it to <tt class="docutils literal">IAmericanSocket</tt> before doing so.
We use the interface object to do this:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">IAmericanSocket</span><span class="p">(</span><span class="n">uk</span><span class="p">)</span>
<span class="go">&lt;__main__.AdaptToAmericanSocket instance at 0x1a5120&gt;</span>
</pre></div>
<p>When calling an interface with an object as an argument, the interface looks in the adapter registry for an adapter which implements the interface for the given instance's class.
If it finds one, it constructs an instance of the Adapter class, passing the constructor the original instance, and returns it.
Now the <tt class="docutils literal">HairDryer</tt> can safely be used with the adapted  <tt class="docutils literal">UKSocket</tt> .
But what happens if we attempt to adapt an object which already implements <tt class="docutils literal">IAmericanSocket</tt>?
We simply get back the original instance:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">IAmericanSocket</span><span class="p">(</span><span class="n">am</span><span class="p">)</span>
<span class="go">&lt;__main__.AmericanSocket instance at 0x36bff0&gt;</span>
</pre></div>
<p>So, we could write a new "smart" <tt class="docutils literal">HairDryer</tt> which automatically looked up an adapter for the socket you tried to plug it into:</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">HairDryer</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">plug</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">socket</span><span class="p">):</span>
        <span class="n">adapted</span> <span class="o">=</span> <span class="n">IAmericanSocket</span><span class="p">(</span><span class="n">socket</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">adapted</span><span class="o">.</span><span class="n">voltage</span><span class="p">()</span> <span class="o">==</span> <span class="mi">120</span><span class="p">,</span> <span class="s2">"BOOM"</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"I was plugged in properly and am operating"</span><span class="p">)</span>
</pre></div>
<p>Now, if we create an instance of our new "smart" <tt class="docutils literal">HairDryer</tt> and attempt to plug it in to various sockets, the <tt class="docutils literal">HairDryer</tt> will adapt itself automatically depending on the type of socket it is plugged in to:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">am</span> <span class="o">=</span> <span class="n">AmericanSocket</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uk</span> <span class="o">=</span> <span class="n">UKSocket</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hd</span> <span class="o">=</span> <span class="n">HairDryer</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hd</span><span class="o">.</span><span class="n">plug</span><span class="p">(</span><span class="n">am</span><span class="p">)</span>
<span class="go">I was plugged in properly and am operating</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hd</span><span class="o">.</span><span class="n">plug</span><span class="p">(</span><span class="n">uk</span><span class="p">)</span>
<span class="go">I was plugged in properly and am operating</span>
</pre></div>
<p>Voila; the magic of components.</p>
<div class="section" id="components-and-inheritance">
<h3><a class="toc-backref" href="#id2">Components and Inheritance</a></h3>
<p>If you inherit from a class which implements some interface, and your new subclass declares that it implements another interface, the implements will be inherited by default.</p>
<p>For example, <cite>pb.Root &lt;twisted.spread.pb.Root&gt;</cite> is a class which implements <cite>IPBRoot &lt;twisted.spread.pb.IPBRoot&gt;</cite>.
This interface indicates that an object has remotely-invokable methods and can be used as the initial object served by a new Broker instance.
It has an <tt class="docutils literal">implements</tt> setting like:</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">zope.interface</span> <span class="kn">import</span> <span class="n">implementer</span>

<span class="nd">@implementer</span><span class="p">(</span><span class="n">IPBRoot</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Root</span><span class="p">(</span><span class="n">Referenceable</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
<p>Suppose you have your own class which implements your <tt class="docutils literal">IMyInterface</tt> interface:</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">zope.interface</span> <span class="kn">import</span> <span class="n">implementer</span><span class="p">,</span> <span class="n">Interface</span>

<span class="k">class</span> <span class="nc">IMyInterface</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="nd">@implementer</span><span class="p">(</span><span class="n">IMyInterface</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">MyThing</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></div>
<p>Now if you want to make this class inherit from <tt class="docutils literal">pb.Root</tt>, the interfaces code will automatically determine that it also implements <tt class="docutils literal">IPBRoot</tt>:</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">twisted.spread</span> <span class="kn">import</span> <span class="n">pb</span>
<span class="kn">from</span> <span class="nn">zope.interface</span> <span class="kn">import</span> <span class="n">implementer</span><span class="p">,</span> <span class="n">Interface</span>

<span class="k">class</span> <span class="nc">IMyInterface</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="nd">@implementer</span><span class="p">(</span><span class="n">IMyInterface</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">MyThing</span><span class="p">(</span><span class="n">pb</span><span class="o">.</span><span class="n">Root</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">twisted.spread.flavors</span> <span class="kn">import</span> <span class="n">IPBRoot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IPBRoot</span><span class="o">.</span><span class="n">implementedBy</span><span class="p">(</span><span class="n">MyThing</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
<p>If you want <tt class="docutils literal">MyThing</tt> to inherit from <tt class="docutils literal">pb.Root</tt> but <em>not</em> implement <tt class="docutils literal">IPBRoot</tt> like <tt class="docutils literal">pb.Root</tt> does, use <tt class="docutils literal">@implementer_only</tt>:</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">twisted.spread</span> <span class="kn">import</span> <span class="n">pb</span>
<span class="kn">from</span> <span class="nn">zope.interface</span> <span class="kn">import</span> <span class="n">implementer_only</span><span class="p">,</span> <span class="n">Interface</span>

<span class="k">class</span> <span class="nc">IMyInterface</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="nd">@implementer_only</span><span class="p">(</span><span class="n">IMyInterface</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">MyThing</span><span class="p">(</span><span class="n">pb</span><span class="o">.</span><span class="n">Root</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">twisted.spread.pb</span> <span class="kn">import</span> <span class="n">IPBRoot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IPBRoot</span><span class="o">.</span><span class="n">implementedBy</span><span class="p">(</span><span class="n">MyThing</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>

</div>
</div>

        </div>
        </div>
        </div>
<div class="sphinxsidebar">
<div class="sphinxsidebarwrapper">
<div class="toc" id="">
<p class="topic-title">Table Of Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#interfaces-and-components-in-twisted-code" id="id1">Interfaces and Components in Twisted code</a><ul>
<li><a class="reference internal" href="#components-and-inheritance" id="id2">Components and Inheritance</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div>    </div>

    </section>

        <div id="footer"><hr>
                <div> </div>
                <p class="left2">
        Copyright 2021, Twisted Matrix Labs. Ver 21.2.0. Built on 2021-02-28.<br />
        Site design<br />
        By <a href="http://huw.ugbox.net/">huw.wilkins.</a>

                </p>
                <p class="right"></p>
        </div>


</body>
</html>