<!DOCTYPE html>
<html lang="en">
<head>
          <title>Test Pelican - Writing Servers</title>
        <meta charset="utf-8" />
        <meta name="generator" content="Pelican" />

        <meta name="Description" content="An event-driven networking engine written in Python and MIT licensed." />

        <link rel="stylesheet" type="text/css" href="https://judgegregg.github.io/pelitwi/theme/css/twistedtrac.css" />


</head>

<body>
        <div id="banner">
                <div id="top_grad"></div>
                <div id="tab">
                        <a href="https://twistedmatrix.com/trac/wiki">HOME</a>
                        <a href="https://twistedmatrix.com/trac/wiki/FrequentlyAskedQuestions">FAQ</a>
                        <a href="/">DOCS</a>
                        <a href="https://twistedmatrix.com/trac/wiki/Downloads">DOWNLOAD</a>
                </div>

                <div id="header">
                        <a id="logo" href="https://judgegregg.github.io/pelitwi/"><img src="https://judgegregg.github.io/pelitwi/theme/images/trac_banner.png" alt="Twisted" /></a>
                </div>
        </div>

<div id="mainnav" class="related">
	<ul>
		<li><a href="https://judgegregg.github.io/pelitwi">Twisted 21.2.0 documentation</a> Â»</li>
	</ul>
</div>
        <div id="ctxtnav" class="nav">
        </div>

    <section>

    <div class="document">
        <div class="documentwrapper">
        <div class="bodywrapper">
        <h1>Writing Servers</h1>
        
        <div class="entry-content">
        <div class="section" id="overview">
<h2><a class="toc-backref" href="#id1">Overview</a></h2>
<p>This document explains how you can use Twisted to implement network protocol parsing and handling for TCP servers (the same code can be reused for SSL and Unix socket servers).
There is a <a class="reference external" href="https://judgegregg.github.io/pelitwi/pages/udp-networking.html">separate document</a> covering UDP.</p>
<p>Your protocol handling class will usually subclass <cite>twisted.internet.protocol.Protocol</cite>.
Most protocol handlers inherit either from this class or from one of its convenience children.
An instance of the protocol class is instantiated per-connection, on demand, and will go away when the connection is finished.
This means that persistent configuration is not saved in the <tt class="docutils literal">Protocol</tt>.</p>
<p>The persistent configuration is kept in a <tt class="docutils literal">Factory</tt> class, which usually inherits from <cite>twisted.internet.protocol.Factory</cite>.
The <tt class="docutils literal">buildProtocol</tt> method of the <tt class="docutils literal">Factory</tt> is used to create a <tt class="docutils literal">Protocol</tt> for each new connection.</p>
<p>It is usually useful to be able to offer the same service on multiple ports or network addresses.
This is why the <tt class="docutils literal">Factory</tt> does not listen to connections, and in fact does not know anything about the network.
See <a class="reference external" href="https://judgegregg.github.io/pelitwi/pages/getting-connected-with-endpoints.html">the endpoints documentation</a> for more information, or <cite>IReactorTCP.listenTCP &lt;twisted.internet.interfaces.IReactorTCP.listenTCP&gt;</cite> and the other <tt class="docutils literal"><span class="pre">IReactor*.listen*</span></tt> APIs for the lower level APIs that endpoints are based on.</p>
<p>This document will explain each step of the way.</p>
</div>
<div class="section" id="protocols">
<h2><a class="toc-backref" href="#id2">Protocols</a></h2>
<p>As mentioned above, this, along with auxiliary classes and functions, is where most of the code is.
A Twisted protocol handles data in an asynchronous manner.
The protocol responds to events as they arrive from the network and the events arrive as calls to methods on the protocol.</p>
<p>Here is a simple example:</p>
<pre class="literal-block">
from twisted.internet.protocol import Protocol

class Echo(Protocol):

    def dataReceived(self, data):
        self.transport.write(data)
</pre>
<p>This is one of the simplest protocols.
It simply writes back whatever is written to it, and does not respond to all events.
Here is an example of a Protocol responding to another event:</p>
<pre class="literal-block">
from twisted.internet.protocol import Protocol

class QOTD(Protocol):

    def connectionMade(self):
        self.transport.write("An apple a day keeps the doctor away\r\n")
        self.transport.loseConnection()
</pre>
<p>This protocol responds to the initial connection with a well known quote, and then terminates the connection.</p>
<p>The <tt class="docutils literal">connectionMade</tt> event is usually where setup of the connection object happens, as well as any initial greetings (as in the QOTD protocol above, which is actually based on <a class="reference external" href="http://tools.ietf.org/html/rfc865.html">RFC 865</a>).
The <tt class="docutils literal">connectionLost</tt> event is where tearing down of any connection-specific objects is done.
Here is an example:</p>
<pre class="literal-block">
from twisted.internet.protocol import Protocol

class Echo(Protocol):

    def __init__(self, factory):
        self.factory = factory

    def connectionMade(self):
        self.factory.numProtocols = self.factory.numProtocols + 1
        self.transport.write(
            "Welcome! There are currently %d open connections.\n" %
            (self.factory.numProtocols,))

    def connectionLost(self, reason):
        self.factory.numProtocols = self.factory.numProtocols - 1

    def dataReceived(self, data):
        self.transport.write(data)
</pre>
<p>Here <tt class="docutils literal">connectionMade</tt> and <tt class="docutils literal">connectionLost</tt> cooperate to keep a count of the active protocols in a shared object, the factory.
The factory must be passed to <tt class="docutils literal">Echo.__init__</tt> when creating a new instance.
The factory is used to share state that exists beyond the lifetime of any given connection.
You will see why this object is called a "factory" in the next section.</p>
<div class="section" id="loseconnection-and-abortconnection">
<h3><a class="toc-backref" href="#id3">loseConnection() and abortConnection()</a></h3>
<p>In the code above, <tt class="docutils literal">loseConnection</tt> is called immediately after writing to the transport.
The <tt class="docutils literal">loseConnection</tt> call will close the connection only when all the data has been written by Twisted out to the operating system, so it is safe to use in this case without worrying about transport writes being lost.
If a <a class="reference external" href="https://judgegregg.github.io/pelitwi/pages/producers-and-consumers-efficient-high-volume-streaming.html">producer</a> is being used with the transport, <tt class="docutils literal">loseConnection</tt> will only close the connection once the producer is unregistered.</p>
<p>In some cases, waiting until all the data is written out is not what we want.
Due to network failures, or bugs or maliciousness in the other side of the connection, data written to the transport may not be deliverable, and so even though <tt class="docutils literal">loseConnection</tt> was called the connection will not be lost.
In these cases, <tt class="docutils literal">abortConnection</tt> can be used: it closes the connection immediately, regardless of buffered data that is still unwritten in the transport, or producers that are still registered.
Note that <tt class="docutils literal">abortConnection</tt> is only available in Twisted 11.1 and newer.</p>
</div>
<div class="section" id="using-the-protocol">
<h3><a class="toc-backref" href="#id4">Using the Protocol</a></h3>
<p>In this section, you will learn how to run a server which uses your <tt class="docutils literal">Protocol</tt>.</p>
<p>Here is code that will run the QOTD server discussed earlier:</p>
<pre class="literal-block">
from twisted.internet.protocol import Factory
from twisted.internet.endpoints import TCP4ServerEndpoint
from twisted.internet import reactor

class QOTDFactory(Factory):
    def buildProtocol(self, addr):
        return QOTD()

# 8007 is the port you want to run under. Choose something &gt;1024
endpoint = TCP4ServerEndpoint(reactor, 8007)
endpoint.listen(QOTDFactory())
reactor.run()
</pre>
<p>In this example, I create a protocol <tt class="docutils literal">Factory</tt>.
I want to tell this factory that its job is to build QOTD protocol instances, so I set its <tt class="docutils literal">buildProtocol</tt> method to return instances of the QOTD class.
Then, I want to listen on a TCP port, so I make a <cite>TCP4ServerEndpoint &lt;twisted.internet.endpoints.TCP4ServerEndpoint&gt;</cite> to identify the port that I want to bind to, and then pass the factory I just created to its <tt class="docutils literal">listen</tt> method.</p>
<p><tt class="docutils literal">endpoint.listen()</tt> tells the reactor to handle connections to the endpoint's address using a particular protocol, but the reactor needs to be <em>running</em> in order for it to do anything.
<tt class="docutils literal">reactor.run()</tt> starts the reactor and then waits forever for connections to arrive on the port you've specified.
You can stop the reactor by hitting Control-C in a terminal or calling <tt class="docutils literal">reactor.stop()</tt>.</p>
<p>For more information on different ways you can listen for incoming connections, see <a class="reference external" href="https://judgegregg.github.io/pelitwi/pages/getting-connected-with-endpoints.html">the documentation for the endpoints API</a>.
For more information on using the reactor, see <a class="reference external" href="https://judgegregg.github.io/pelitwi/pages/reactor-overview.html">the reactor overview</a>.</p>
</div>
<div class="section" id="helper-protocols">
<h3><a class="toc-backref" href="#id5">Helper Protocols</a></h3>
<p>Many protocols build upon similar lower-level abstractions.</p>
<p>For example, many popular internet protocols are line-based, containing text data terminated by line breaks (commonly CR-LF), rather than containing straight raw data.
However, quite a few protocols are mixed - they have line-based sections and then raw data sections.
Examples include HTTP/1.1 and the Freenet protocol.</p>
<p>For those cases, there is the <cite>LineReceiver &lt;twisted.protocols.basic.LineReceiver&gt;</cite> protocol.
This protocol dispatches to two different event handlers -- <tt class="docutils literal">lineReceived</tt> and <tt class="docutils literal">rawDataReceived</tt>.
By default, only <tt class="docutils literal">lineReceived</tt> will be called, once for each line.
However, if <tt class="docutils literal">setRawMode</tt> is called, the protocol will call <tt class="docutils literal">rawDataReceived</tt> until <tt class="docutils literal">setLineMode</tt> is called, which returns it to using <tt class="docutils literal">lineReceived</tt>.
It also provides a method, <tt class="docutils literal">sendLine</tt>, that writes data to the transport along with the delimiter the class uses to split lines (by default, <tt class="docutils literal">\r\n</tt>).</p>
<p>Here is an example for a simple use of the line receiver:</p>
<pre class="literal-block">
from twisted.protocols.basic import LineReceiver

class Answer(LineReceiver):

    answers = {'How are you?': 'Fine', None: "I don't know what you mean"}

    def lineReceived(self, line):
        if line in self.answers:
            self.sendLine(self.answers[line])
        else:
            self.sendLine(self.answers[None])
</pre>
<p>Note that the delimiter is not part of the line.</p>
<p>Several other helpers exist, such as a <cite>netstring based protocol &lt;twisted.protocols.basic.NetstringReceiver&gt;</cite> and <cite>prefixed-message-length protocols &lt;twisted.protocols.basic.IntNStringReceiver&gt;</cite>.</p>
</div>
<div class="section" id="state-machines">
<h3><a class="toc-backref" href="#id6">State Machines</a></h3>
<p>Many Twisted protocol handlers need to write a state machine to record the state they are at.
Here are some pieces of advice which help to write state machines:</p>
<ul class="simple">
<li>Don't write big state machines.
Prefer to write a state machine which deals with one level of abstraction at a time.</li>
<li>Don't mix application-specific code with Protocol handling code.
When the protocol handler has to make an application-specific call, keep it as a method call.</li>
</ul>
</div>
</div>
<div class="section" id="factories">
<h2><a class="toc-backref" href="#id7">Factories</a></h2>
<div class="section" id="simpler-protocol-creation">
<h3><a class="toc-backref" href="#id8">Simpler Protocol Creation</a></h3>
<p>For a factory which simply instantiates instances of a specific protocol class, there is a simpler way to implement the factory.
The default implementation of the <tt class="docutils literal">buildProtocol</tt> method calls the <tt class="docutils literal">protocol</tt> attribute of the factory to create a <tt class="docutils literal">Protocol</tt> instance, and then sets an attribute on it called <tt class="docutils literal">factory</tt> which points to the factory itself.
This lets every <tt class="docutils literal">Protocol</tt> access, and possibly modify, the persistent configuration.
Here is an example that uses these features instead of overriding <tt class="docutils literal">buildProtocol</tt>:</p>
<pre class="literal-block">
from twisted.internet.protocol import Factory, Protocol
from twisted.internet.endpoints import TCP4ServerEndpoint
from twisted.internet import reactor

class QOTD(Protocol):

    def connectionMade(self):
        # self.factory was set by the factory's default buildProtocol:
        self.transport.write(self.factory.quote + '\r\n')
        self.transport.loseConnection()


class QOTDFactory(Factory):

    # This will be used by the default buildProtocol to create new protocols:
    protocol = QOTD

    def __init__(self, quote=None):
        self.quote = quote or 'An apple a day keeps the doctor away'

endpoint = TCP4ServerEndpoint(reactor, 8007)
endpoint.listen(QOTDFactory("configurable quote"))
reactor.run()
</pre>
<p>If all you need is a simple factory that builds a protocol without any additional behavior, Twisted 13.1 added <cite>Factory.forProtocol &lt;twisted.internet.protocol.Factory.forProtocol&gt;</cite>, an even simpler approach.</p>
</div>
<div class="section" id="factory-startup-and-shutdown">
<h3><a class="toc-backref" href="#id9">Factory Startup and Shutdown</a></h3>
<p>A Factory has two methods to perform application-specific building up and tearing down (since a Factory is frequently persisted, it is often not appropriate to do them in <tt class="docutils literal">__init__</tt> or <tt class="docutils literal">__del__</tt>, and would frequently be too early or too late).</p>
<p>Here is an example of a factory which allows its Protocols to write to a special log-file:</p>
<pre class="literal-block">
from twisted.internet.protocol import Factory
from twisted.protocols.basic import LineReceiver


class LoggingProtocol(LineReceiver):

    def lineReceived(self, line):
        self.factory.fp.write(line + '\n')


class LogfileFactory(Factory):

    protocol = LoggingProtocol

    def __init__(self, fileName):
        self.file = fileName

    def startFactory(self):
        self.fp = open(self.file, 'a')

    def stopFactory(self):
        self.fp.close()
</pre>
</div>
</div>
<div class="section" id="putting-it-all-together">
<h2><a class="toc-backref" href="#id10">Putting it All Together</a></h2>
<p>As a final example, here's a simple chat server that allows users to choose a username and then communicate with other users.
It demonstrates the use of shared state in the factory, a state machine for each individual protocol, and communication between different protocols.</p>
<p><cite>chat.py &lt;listings/servers/chat.py&gt;</cite></p>
<p>The only API you might not be familiar with is <tt class="docutils literal">listenTCP</tt>.
<cite>listenTCP &lt;twisted.internet.interfaces.IReactorTCP.listenTCP&gt;</cite> is the method which connects a <tt class="docutils literal">Factory</tt> to the network.
This is the lower-level API that <a class="reference external" href="https://judgegregg.github.io/pelitwi/pages/getting-connected-with-endpoints.html">endpoints</a> wraps for you.</p>
<p>Here's a sample transcript of a chat session (emphasised text is entered by the user):</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>telnet <span class="m">127</span>.0.0.1 <span class="m">8123</span>
<span class="go">Trying 127.0.0.1...</span>
<span class="go">Connected to 127.0.0.1.</span>
<span class="go">Escape character is '^]'.</span>
<span class="go">What's your name?</span>
<span class="go">test</span>
<span class="go">Name taken, please choose another.</span>
<span class="go">bob</span>
<span class="go">Welcome, bob!</span>
<span class="go">hello</span>
<span class="go">&lt;alice&gt; hi bob</span>
<span class="go">twisted makes writing servers so easy!</span>
<span class="go">&lt;alice&gt; I couldn't agree more</span>
<span class="go">&lt;carrol&gt; yeah, it's great</span>
</pre></div>

</div>

        </div>
        </div>
        </div>
<div class="sphinxsidebar">
<div class="sphinxsidebarwrapper">
<div class="toc" id="">
<p class="topic-title">Table Of Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#overview" id="id1">Overview</a></li>
<li><a class="reference internal" href="#protocols" id="id2">Protocols</a><ul>
<li><a class="reference internal" href="#loseconnection-and-abortconnection" id="id3">loseConnection() and abortConnection()</a></li>
<li><a class="reference internal" href="#using-the-protocol" id="id4">Using the Protocol</a></li>
<li><a class="reference internal" href="#helper-protocols" id="id5">Helper Protocols</a></li>
<li><a class="reference internal" href="#state-machines" id="id6">State Machines</a></li>
</ul>
</li>
<li><a class="reference internal" href="#factories" id="id7">Factories</a><ul>
<li><a class="reference internal" href="#simpler-protocol-creation" id="id8">Simpler Protocol Creation</a></li>
<li><a class="reference internal" href="#factory-startup-and-shutdown" id="id9">Factory Startup and Shutdown</a></li>
</ul>
</li>
<li><a class="reference internal" href="#putting-it-all-together" id="id10">Putting it All Together</a></li>
</ul>
</div>

<h4>Previous topic</h4>
<p class="topless">
<a href=https://judgegregg.github.io/pelitwi/pages/the-vision-for-twisted.html>The Vision For Twisted</a>
</p>
<h4>Next topic</h4>
<p class="topless">
<a href=https://judgegregg.github.io/pelitwi/pages/writing-clients.html>Writing Clients</a>
</p>
</div>
</div>    </div>

    </section>

        <div id="footer"><hr>
                <div> </div>
                <p class="left2">
        Copyright 2021, Twisted Matrix Labs. Ver 21.2.0. Built on 2021-02-28.<br />
        Site design<br />
        By <a href="http://huw.ugbox.net/">huw.wilkins.</a>

                </p>
                <p class="right"></p>
        </div>


</body>
</html>