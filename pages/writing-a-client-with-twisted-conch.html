<!DOCTYPE html>
<html lang="en">
<head>
          <title>Test Pelican - Writing a client with Twisted Conch</title>
        <meta charset="utf-8" />
        <meta name="generator" content="Pelican" />

        <meta name="Description" content="An event-driven networking engine written in Python and MIT licensed." />

        <link rel="stylesheet" type="text/css" href="https://judgegregg.github.io/pelitwi/theme/css/twistedtrac.css" />


</head>

<body>
        <div id="banner">
                <div id="top_grad"></div>
                <div id="tab">
                        <a href="https://twistedmatrix.com/trac/wiki">HOME</a>
                        <a href="https://twistedmatrix.com/trac/wiki/FrequentlyAskedQuestions">FAQ</a>
                        <a href="/">DOCS</a>
                        <a href="https://twistedmatrix.com/trac/wiki/Downloads">DOWNLOAD</a>
                </div>

                <div id="header">
                        <a id="logo" href="https://judgegregg.github.io/pelitwi/"><img src="https://judgegregg.github.io/pelitwi/theme/images/trac_banner.png" alt="Twisted" /></a>
                </div>
        </div>

<div id="mainnav" class="related">
	<ul>
		<li><a href="https://judgegregg.github.io/pelitwi">Twisted 21.2.0 documentation</a> Â»</li>
	</ul>
</div>
        <div id="ctxtnav" class="nav">
        </div>

    <section>

    <div class="document">
        <div class="documentwrapper">
        <div class="bodywrapper">
        <h1>Writing a client with Twisted Conch</h1>
        
        <div class="entry-content">
        <div class="section" id="introduction">
<h2><a class="toc-backref" href="#id1">Introduction</a></h2>
<p>In the original days of computing, rsh/rlogin were used to connect to
remote computers and execute commands. These commands had the problem
that the passwords and commands were sent in the clear. To solve this
problem, the SSH protocol was created. Twisted Conch implements the
second version of this protocol.</p>
</div>
<div class="section" id="using-an-ssh-command-endpoint">
<h2><a class="toc-backref" href="#id2">Using an SSH Command Endpoint</a></h2>
<p>If your objective is to execute a command on a remote host over an SSH
connection, then the easiest approach may be to
use <cite>twisted.conch.endpoints.SSHCommandClientEndpoint</cite> .
If you haven't used endpoints before, first take a look
at <a class="reference external" href="https://judgegregg.github.io/pelitwi/pages/getting-connected-with-endpoints.html">the endpoint howto</a> to
get an idea of how endpoints work in general.</p>
<p>Conch provides an endpoint implementation which establishes an SSH
connection, performs necessary authentication, opens a channel, and
launches a command in that channel.  It then associates the output of that
command with the input of a protocol you supply, and associates output
from that protocol with the input of that command.  Effectively,
this lets you ignore most of the complexity of SSH and just interact with
a remote process as though it were any other stream-oriented connection -
such as TCP or SSL.</p>
<p>Conch also provides an endpoint that is initialized with an already
established SSH connection.  This endpoint just opens a new channel on the
existing connection and launches a command in that.</p>
<p>Using the <tt class="docutils literal">SSHCommandClientEndpoint</tt> is about as simple as using any
other stream-oriented client endpoint.  Just create the endpoint defining
where the SSH server to connect to is and a factory defining what kind of
protocol to use to interact with the command and let them get to work
using the endpoint's <tt class="docutils literal">connect</tt> method.</p>
<p><cite>echoclient_ssh.py &lt;listings/echoclient_ssh.py&gt;</cite></p>
<p>For completeness, this example includes a lot of code to support different
styles of authentication, reading (and possibly updating) existing
<em>known_hosts</em> files, and parsing command line options.  Focus on
the latter half of the <tt class="docutils literal">main</tt> function to see the code that is
most directly responsible for actually doing the necessary SSH connection
setup.  <tt class="docutils literal">SSHCommandClientEndpoint</tt> accepts quite a few options, since
there is a lot of flexibility in SSH and many possible different server
configurations, but once the endpoint object itself is created, its use is
no more complicated than the use of any other endpoint: pass a factory to
its <tt class="docutils literal">connect</tt> method and attach a callback to the
resulting <tt class="docutils literal">Deferred</tt> to do something with the protocol
instance. If you use an endpoint that creates new connections, the connection
attempt can be cancelled by calling <tt class="docutils literal">cancel()</tt> on this
<tt class="docutils literal">Deferred</tt> .</p>
<p>In this case, the connected protocol instance is only used to make the
example wait until the client has finished talking to the server, which
happens after the small amount of example data has been sent to the server
and bounced back by the <tt class="docutils literal">/bin/cat</tt> process the
protocol is interacting with.</p>
<p>Several of the options accepted by <tt class="docutils literal">SSHCommandClientEndpoint.newConnection</tt> should be easy to understand.
The endpoint takes a reactor which it uses to do any and all I/O it needs to do.
It also takes a command which it executes on the remote server once the SSH connection is established and authenticated; this command is a single string, perhaps including spaces or other special shell symbols, and is interpreted by a shell on the server.
It takes a username with which it identifies itself to the server for authentication purposes.
It takes an optional password argument which will also be used for authentication - if the server supports password authentication (prefer keys instead where possible, see below).
It takes a host (either a name or an IP address) and a port number, defining where to connect.</p>
<p>Some of the other options may bear further explanation.</p>
<p>The <tt class="docutils literal">keys</tt> argument gives any SSH <cite>Key &lt;twisted.conch.ssh.keys.Key&gt;</cite> objects which may be useful for authentication.
These keys are available to the endpoint for authentication, but only keys that the server indicates are useful will actually be used.
This argument is optional.
If key authentication against the server is either unnecessary or undesired, it may be omitted entirely.</p>
<p>The <tt class="docutils literal">agentEndpoint</tt> argument gives the <tt class="docutils literal">SSHCommandClientEndpoint</tt> an opportunity to connect to an SSH authentication agent.
The agent may already be loaded with keys, or may have some other way to authenticate a connection.
Using the agent can mean the process actually establishing the SSH connection doesn't need to load any authentication material (passwords or keys) itself (often convenient in case keys are encrypted and potentially more secure, since only the agent process ever actually holds the secrets).
The value for this argument is another <tt class="docutils literal">IStreamClientEndpoint</tt> .
Often in a typical <em>NIX desktop environment, the *SSH_AUTH_SOCK</em> environment variable will give the location of an AF_UNIX socket.
This explains the value <tt class="docutils literal">echoclient_ssh.py</tt> assigns this parameter when <em>--no-agent</em> is not given.</p>
<p>The <tt class="docutils literal">knownHosts</tt> argument accepts a <cite>KnownHostsFile &lt;twisted.conch.client.knownhosts.KnownHostsFile&gt;</cite> instance and controls how server keys are checked and stored.
This object has the opportunity to reject server keys if they differ from expectations.
It can also save server keys when they are first observed.</p>
<p>Finally, there is one option that is not demonstrated in the example - the <tt class="docutils literal">ui</tt> argument.
This argument is closely related to the <tt class="docutils literal">knownHosts</tt> argument described above.
<tt class="docutils literal">KnownHostsFile</tt> may require user-input under certain circumstances - for example, to ask if it should accept a server key the first time it is observed.
The <tt class="docutils literal">ui</tt> object is how this user-input is obtained.
By default, a <cite>ConsoleUI &lt;twisted.conch.client.knownhosts.ConsoleUI&gt;</cite> instance associated with <em>/dev/tty</em> will be used.
This gives about the same behavior as is seen in a standard command-line ssh client.
See <cite>SSHCommandClientEndpoint.newConnection &lt;twisted.conch.endpoints.SSHCommandClientEndpoint.newConnection&gt;</cite> for details about how edge cases are handled for this default value.
For use of <tt class="docutils literal">SSHCommandClientEndpoint</tt> that is intended to be completely autonomous, applications will probably want to specify a custom <tt class="docutils literal">ui</tt> object which can make the necessary decisions without user-input.</p>
<p>It is also possible to run commands (one or more) over an
already-established connection.  This is done using the alternate
constructor <tt class="docutils literal">SSHCommandClientEndpoint.existingConnection</tt> .  The
<tt class="docutils literal">connection</tt> argument to that function can be obtained by accessing
<tt class="docutils literal">transport.conn</tt> on an already connected protocol.</p>
<p><cite>echoclient_shared_ssh.py &lt;listings/echoclient_shared_ssh.py&gt;</cite></p>
</div>
<div class="section" id="writing-a-client">
<h2><a class="toc-backref" href="#id3">Writing a client</a></h2>
<p>In case the endpoint is missing some necessary functionality, or in case you
want to interact with a different part of an SSH server - such as one of
its <em>subsystems</em> (for example, SFTP), you may need to use the
lower-level Conch client interface.  This is described below.</p>
<p>Writing a client with Conch involves sub-classing 4 classes: <cite>twisted.conch.ssh.transport.SSHClientTransport</cite> , <cite>twisted.conch.ssh.userauth.SSHUserAuthClient</cite> , <cite>twisted.conch.ssh.connection.SSHConnection</cite> , and <cite>twisted.conch.ssh.channel.SSHChannel</cite> . We'll start out
with <tt class="docutils literal">SSHClientTransport</tt> because it's the base
of the client.</p>
</div>
<div class="section" id="the-transport">
<h2><a class="toc-backref" href="#id4">The Transport</a></h2>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">twisted.conch</span> <span class="kn">import</span> <span class="n">error</span>
<span class="kn">from</span> <span class="nn">twisted.conch.ssh</span> <span class="kn">import</span> <span class="n">transport</span>
<span class="kn">from</span> <span class="nn">twisted.internet</span> <span class="kn">import</span> <span class="n">defer</span>

<span class="k">class</span> <span class="nc">ClientTransport</span><span class="p">(</span><span class="n">transport</span><span class="o">.</span><span class="n">SSHClientTransport</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">verifyHostKey</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pubKey</span><span class="p">,</span> <span class="n">fingerprint</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fingerprint</span> <span class="o">!=</span> <span class="s1">'b1:94:6a:c9:24:92:d2:34:7c:62:35:b4:d2:61:11:84'</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">defer</span><span class="o">.</span><span class="n">fail</span><span class="p">(</span><span class="n">error</span><span class="o">.</span><span class="n">ConchError</span><span class="p">(</span><span class="s1">'bad key'</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">defer</span><span class="o">.</span><span class="n">succeed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">connectionSecure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">requestService</span><span class="p">(</span><span class="n">ClientUserAuth</span><span class="p">(</span><span class="s1">'user'</span><span class="p">,</span> <span class="n">ClientConnection</span><span class="p">()))</span>
</pre></div>
<p>See how easy it is? <tt class="docutils literal">SSHClientTransport</tt>
handles the negotiation of encryption and the verification of keys
for you. The one security element that you as a client writer need to
implement is <tt class="docutils literal">verifyHostKey()</tt> . This method
is called with two strings: the public key sent by the server and its
fingerprint. You should verify the host key the server sends, either
by checking against a hard-coded value as in the example, or by asking
the user. <tt class="docutils literal">verifyHostKey</tt> returns a <cite>twisted.internet.defer.Deferred</cite> which gets a callback
if the host key is valid, or an errback if it is not. Note that in the
above, replace 'user' with the username you're attempting to ssh with,
for instance a call to <tt class="docutils literal">os.getlogin()</tt> for the
current user.</p>
<p>The second method you need to implement is <tt class="docutils literal">connectionSecure()</tt> . It is called when the
encryption is set up and other services can be run. The example requests
that the <tt class="docutils literal">ClientUserAuth</tt> service be started.
This service will be discussed next.</p>
</div>
<div class="section" id="the-authorization-client">
<h2><a class="toc-backref" href="#id5">The Authorization Client</a></h2>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">twisted.conch.ssh</span> <span class="kn">import</span> <span class="n">keys</span><span class="p">,</span> <span class="n">userauth</span>

<span class="c1"># these are the public/private keys from test_conch</span>

<span class="n">publicKey</span> <span class="o">=</span> <span class="s1">'ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAGEArzJx8OYOnJmzf4tfBEvLi8DVPrJ3</span><span class="se">\</span>
<span class="s1">/c9k2I/Az64fxjHf9imyRJbixtQhlH9lfNjUIx+4LmrJH5QNRsFporcHDKOTwTTYLh5KmRpslkYHR</span><span class="se">\</span>
<span class="s1">ivcJSkbh/C+BR3utDS555mV'</span>

<span class="n">privateKey</span> <span class="o">=</span> <span class="s2">"""-----BEGIN RSA PRIVATE KEY-----</span>
<span class="s2">MIIByAIBAAJhAK8ycfDmDpyZs3+LXwRLy4vA1T6yd/3PZNiPwM+uH8Yx3/YpskSW</span>
<span class="s2">4sbUIZR/ZXzY1CMfuC5qyR+UDUbBaaK3Bwyjk8E02C4eSpkabJZGB0Yr3CUpG4fw</span>
<span class="s2">vgUd7rQ0ueeZlQIBIwJgbh+1VZfr7WftK5lu7MHtqE1S1vPWZQYE3+VUn8yJADyb</span>
<span class="s2">Z4fsZaCrzW9lkIqXkE3GIY+ojdhZhkO1gbG0118sIgphwSWKRxK0mvh6ERxKqIt1</span>
<span class="s2">xJEJO74EykXZV4oNJ8sjAjEA3J9r2ZghVhGN6V8DnQrTk24Td0E8hU8AcP0FVP+8</span>
<span class="s2">PQm/g/aXf2QQkQT+omdHVEJrAjEAy0pL0EBH6EVS98evDCBtQw22OZT52qXlAwZ2</span>
<span class="s2">gyTriKFVoqjeEjt3SZKKqXHSApP/AjBLpF99zcJJZRq2abgYlf9lv1chkrWqDHUu</span>
<span class="s2">DZttmYJeEfiFBBavVYIF1dOlZT0G8jMCMBc7sOSZodFnAiryP+Qg9otSBjJ3bQML</span>
<span class="s2">pSTqy7c3a2AScC/YyOwkDaICHnnD3XyjMwIxALRzl0tQEKMXs6hH8ToUdlLROCrP</span>
<span class="s2">EhQ0wahUTCk1gKA4uPD6TMTChavbh4K63OvbKg==</span>
<span class="s2">-----END RSA PRIVATE KEY-----"""</span>

<span class="k">class</span> <span class="nc">ClientUserAuth</span><span class="p">(</span><span class="n">userauth</span><span class="o">.</span><span class="n">SSHUserAuthClient</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">getPassword</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prompt</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span>
        <span class="c1"># this says we won't do password authentication</span>

    <span class="k">def</span> <span class="nf">getPublicKey</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">keys</span><span class="o">.</span><span class="n">Key</span><span class="o">.</span><span class="n">fromString</span><span class="p">(</span><span class="n">data</span> <span class="o">=</span> <span class="n">publicKey</span><span class="p">)</span><span class="o">.</span><span class="n">blob</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">getPrivateKey</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">defer</span><span class="o">.</span><span class="n">succeed</span><span class="p">(</span><span class="n">keys</span><span class="o">.</span><span class="n">Key</span><span class="o">.</span><span class="n">fromString</span><span class="p">(</span><span class="n">data</span> <span class="o">=</span> <span class="n">privateKey</span><span class="p">)</span><span class="o">.</span><span class="n">keyObject</span><span class="p">)</span>
</pre></div>
<p>Again, fairly simple. The <tt class="docutils literal">SSHUserAuthClient</tt> takes care of most
of the work, but the actual authentication data needs to be
supplied. <tt class="docutils literal">getPassword()</tt> asks for a
password, <tt class="docutils literal">getPublicKey()</tt> and <tt class="docutils literal">getPrivateKey()</tt> get public and private keys,
respectively. <tt class="docutils literal">getPassword()</tt> returns
a <tt class="docutils literal">Deferred</tt> that is called back with
the password to use.</p>
<p><tt class="docutils literal">getPublicKey()</tt> returns the SSH key data for the public key to use.
<cite>Key.fromString() &lt;twisted.conch.ssh.keys.Key.fromString&gt;</cite> will take a key in OpenSSH, LSH or any supported format, as a string, and generate a new <cite>Key &lt;twisted.conch.ssh.keys.Key&gt;</cite>.
Alternatively, <tt class="docutils literal">keys.Key.fromFile()</tt> can be used instead, which
will take the filename of a key in the supported format, and  and generate a new  <cite>Key &lt;twisted.conch.ssh.keys.Key&gt;</cite>.</p>
<p><tt class="docutils literal">getPrivateKey()</tt> returns a <tt class="docutils literal">Deferred</tt> which is called back with the private <cite>Key &lt;twisted.conch.ssh.keys.Key&gt;</cite>.</p>
<p><tt class="docutils literal">getPassword()</tt> and <tt class="docutils literal">getPrivateKey()</tt> return <tt class="docutils literal">Deferreds</tt> because they may need to ask the user for input.</p>
<p>Once the authentication is complete, <tt class="docutils literal">SSHUserAuthClient</tt> takes care of starting the <tt class="docutils literal">SSHConnection</tt> object given to it. Next, we'll
look at how to use the <tt class="docutils literal">SSHConnection</tt>.</p>
</div>
<div class="section" id="the-connection">
<h2><a class="toc-backref" href="#id6">The Connection</a></h2>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">twisted.conch.ssh</span> <span class="kn">import</span> <span class="n">connection</span>

<span class="k">class</span> <span class="nc">ClientConnection</span><span class="p">(</span><span class="n">connection</span><span class="o">.</span><span class="n">SSHConnection</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">serviceStarted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">openChannel</span><span class="p">(</span><span class="n">CatChannel</span><span class="p">(</span><span class="n">conn</span> <span class="o">=</span> <span class="bp">self</span><span class="p">))</span>
</pre></div>
<p><tt class="docutils literal">SSHConnection</tt> is the easiest,
as it's only responsible for starting the channels. It has
other methods, those will be examined when we look at <tt class="docutils literal">SSHChannel</tt> .</p>
</div>
<div class="section" id="the-channel">
<h2><a class="toc-backref" href="#id7">The Channel</a></h2>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">twisted.conch.ssh</span> <span class="kn">import</span> <span class="n">channel</span><span class="p">,</span> <span class="n">common</span>

<span class="k">class</span> <span class="nc">CatChannel</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">SSHChannel</span><span class="p">):</span>

    <span class="n">name</span> <span class="o">=</span> <span class="s1">'session'</span>

    <span class="k">def</span> <span class="nf">channelOpen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">sendRequest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'exec'</span><span class="p">,</span> <span class="n">common</span><span class="o">.</span><span class="n">NS</span><span class="p">(</span><span class="s1">'cat'</span><span class="p">),</span>
                                  <span class="n">wantReply</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">d</span><span class="o">.</span><span class="n">addCallback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbSendRequest</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">catData</span> <span class="o">=</span> <span class="s1">''</span>

    <span class="k">def</span> <span class="nf">_cbSendRequest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ignored</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">'This data will be echoed back to us by "cat."</span><span class="se">\r\n</span><span class="s1">'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">sendEOF</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loseConnection</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">dataReceived</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">catData</span> <span class="o">+=</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">closed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'We got this from "cat":'</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">catData</span><span class="p">)</span>
</pre></div>
<p>Now that we've spent all this time getting the server and
client connected, here is where that work pays off. <tt class="docutils literal">SSHChannel</tt> is the interface between you and the
other side. This particular channel opens a session and plays with the
'cat' program, but your channel can implement anything, so long as the
server supports it.</p>
<p>The <tt class="docutils literal">channelOpen()</tt> method is
where everything gets started. It gets passed a chunk of data;
however, this chunk is usually nothing and can be ignored.
Our <tt class="docutils literal">channelOpen()</tt> initializes our
channel, and sends a request to the other side, using the <tt class="docutils literal">sendRequest()</tt> method of the <tt class="docutils literal">SSHConnection</tt> object. Requests are used to send
events to the other side. We pass the method self so that it knows to
send the request for this channel. The 2nd argument of 'exec' tells the
server that we want to execute a command. The third argument is the data
that accompanies the request. <cite>common.NS &lt;twisted.conch.ssh.common.NS&gt;</cite> encodes
the data as a length-prefixed string, which is how the server expects
the data. We also say that we want a reply saying that the process has a
been started. <tt class="docutils literal">sendRequest()</tt> then returns a <tt class="docutils literal">Deferred</tt> which we add a callback for.</p>
<p>Once the callback fires, we send the data. <tt class="docutils literal">SSHChannel</tt> supports the <cite>twisted.internet.interfaces.ITransport</cite>
interface, so
it can be given to Protocols to run them over the secure
connection. In our case, we just write the data directly. <tt class="docutils literal">sendEOF()</tt> does not follow the interface,
but Conch uses it to tell the other side that we will write no
more data. <tt class="docutils literal">loseConnection()</tt> shuts
down our side of the connection, but we will still receive data
through <tt class="docutils literal">dataReceived()</tt> . The <tt class="docutils literal">closed()</tt> method is called when both sides of the
connection are closed, and we use it to display the data we received
(which should be the same as the data we sent.)</p>
<p>Finally, let's actually invoke the code we've set up.</p>
</div>
<div class="section" id="the-main-function">
<h2><a class="toc-backref" href="#id8">The main() function</a></h2>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">twisted.internet</span> <span class="kn">import</span> <span class="n">protocol</span><span class="p">,</span> <span class="n">reactor</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">factory</span> <span class="o">=</span> <span class="n">protocol</span><span class="o">.</span><span class="n">ClientFactory</span><span class="p">()</span>
    <span class="n">factory</span><span class="o">.</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">ClientTransport</span>
    <span class="n">reactor</span><span class="o">.</span><span class="n">connectTCP</span><span class="p">(</span><span class="s1">'localhost'</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="n">factory</span><span class="p">)</span>
    <span class="n">reactor</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">"__main__"</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>We call <tt class="docutils literal">connectTCP()</tt> to connect to
localhost, port 22 (the standard port for ssh), and pass it an instance
of <cite>twisted.internet.protocol.ClientFactory</cite> .
This instance has the attribute <tt class="docutils literal">protocol</tt>
set to our earlier <tt class="docutils literal">ClientTransport</tt>
class. Note that the protocol attribute is set to the class <tt class="docutils literal">ClientTransport</tt> , not an instance of <tt class="docutils literal">ClientTransport</tt> ! When the <tt class="docutils literal">connectTCP</tt> call completes, the protocol will be
called to create a <tt class="docutils literal">ClientTransport()</tt> object
- this then invokes all our previous work.</p>
<p>It's worth noting that in the example <tt class="docutils literal">main()</tt>
routine, the <tt class="docutils literal">reactor.run()</tt> call never returns.
If you want to make the program exit, call <tt class="docutils literal">reactor.stop()</tt> in the earlier <tt class="docutils literal">closed()</tt> method.</p>
<p>If you wish to observe the interactions in more detail, adding a call
to <tt class="docutils literal">log.startLogging(sys.stdout, setStdout=0)</tt>
before the <tt class="docutils literal">reactor.run()</tt> call will send all
logging to stdout.</p>

</div>

        </div>
        </div>
        </div>
<div class="sphinxsidebar">
<div class="sphinxsidebarwrapper">
<div class="toc" id="">
<p class="topic-title">Table Of Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id1">Introduction</a></li>
<li><a class="reference internal" href="#using-an-ssh-command-endpoint" id="id2">Using an SSH Command Endpoint</a></li>
<li><a class="reference internal" href="#writing-a-client" id="id3">Writing a client</a></li>
<li><a class="reference internal" href="#the-transport" id="id4">The Transport</a></li>
<li><a class="reference internal" href="#the-authorization-client" id="id5">The Authorization Client</a></li>
<li><a class="reference internal" href="#the-connection" id="id6">The Connection</a></li>
<li><a class="reference internal" href="#the-channel" id="id7">The Channel</a></li>
<li><a class="reference internal" href="#the-main-function" id="id8">The main() function</a></li>
</ul>
</div>
</div>
</div>    </div>

    </section>

        <div id="footer"><hr>
                <div> </div>
                <p class="left2">
        Copyright 2021, Twisted Matrix Labs. Ver 21.2.0. Built on 2021-02-28.<br />
        Site design<br />
        By <a href="http://huw.ugbox.net/">huw.wilkins.</a>

                </p>
                <p class="right"></p>
        </div>


</body>
</html>