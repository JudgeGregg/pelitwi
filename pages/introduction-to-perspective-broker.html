<!DOCTYPE html>
<html lang="en">
<head>
          <title>Test Pelican - Introduction to Perspective Broker</title>
        <meta charset="utf-8" />
        <meta name="generator" content="Pelican" />

        <meta name="Description" content="An event-driven networking engine written in Python and MIT licensed." />

        <link rel="stylesheet" type="text/css" href="https://judgegregg.github.io/pelitwi/theme/css/twistedtrac.css" />


</head>

<body>
        <div id="banner">
                <div id="top_grad"></div>
                <div id="tab">
                        <a href="https://twistedmatrix.com/trac/wiki">HOME</a>
                        <a href="https://twistedmatrix.com/trac/wiki/FrequentlyAskedQuestions">FAQ</a>
                        <a href="/">DOCS</a>
                        <a href="https://twistedmatrix.com/trac/wiki/Downloads">DOWNLOAD</a>
                </div>

                <div id="header">
                        <a id="logo" href="https://judgegregg.github.io/pelitwi/"><img src="https://judgegregg.github.io/pelitwi/theme/images/trac_banner.png" alt="Twisted" /></a>
                </div>
        </div>

<div id="mainnav" class="related">
	<ul>
		<li><a href="https://judgegregg.github.io/pelitwi">Twisted 21.2.0 documentation</a> Â»</li>
	</ul>
</div>
        <div id="ctxtnav" class="nav">
        </div>

    <section>

    <div class="document">
        <div class="documentwrapper">
        <div class="bodywrapper">
        <h1>Introduction to Perspective Broker</h1>
        
        <div class="entry-content">
        <div class="section" id="introduction">
<h2><a class="toc-backref" href="#id3">Introduction</a></h2>
<p>Suppose you find yourself in control of both ends of the wire: you
have two programs that need to talk to each other, and you get to use any
protocol you want. If you can think of your problem in terms of objects that
need to make method calls on each other, then chances are good that you can
use Twisted's Perspective Broker protocol rather than trying to shoehorn
your needs into something like HTTP, or implementing yet another RPC
mechanism <a class="footnote-reference" href="#id2" id="id1">[1]</a> .</p>
<p>The Perspective Broker system (abbreviated "PB" , spawning numerous
sandwich-related puns) is based upon a few central concepts:</p>
<ul class="simple">
<li><em>serialization</em> : taking fairly arbitrary objects and types,
turning them into a chunk of bytes, sending them over a wire, then
reconstituting them on the other end. By keeping careful track of object
ids, the serialized objects can contain references to other objects and
the remote copy will still be useful.</li>
<li><em>remote method calls</em> : doing something to a local object and
causing a method to get run on a distant one. The local object is called a
<cite>RemoteReference &lt;twisted.spread.pb.RemoteReference&gt;</cite> , and you
"do something" by running its <tt class="docutils literal">.callRemote</tt> method.</li>
</ul>
<p>This document will contain several examples that will (hopefully) appear
redundant and verbose once you've figured out what's going on. To begin
with, much of the code will just be labelled "magic" : don't worry about how
these parts work yet. It will be explained more fully later.</p>
</div>
<div class="section" id="object-roadmap">
<h2><a class="toc-backref" href="#id4">Object Roadmap</a></h2>
<p>To start with, here are the major classes, interfaces, and
functions involved in PB, with links to the file where they are
defined (all of which are under twisted/, of course). Don't worry
about understanding what they all do yet: it's easier to figure them
out through their interaction than explaining them one at a time.</p>
<ul class="simple">
<li><cite>Factory &lt;twisted.internet.protocol.Factory&gt;</cite>
: <tt class="docutils literal">internet/protocol.py</tt></li>
<li><cite>PBServerFactory &lt;twisted.spread.pb.PBServerFactory&gt;</cite>
: <tt class="docutils literal">spread/pb.py</tt></li>
<li><cite>Broker &lt;twisted.spread.pb.Broker&gt;</cite>
: <tt class="docutils literal">spread/pb.py</tt></li>
</ul>
<p>Other classes that are involved at some point:</p>
<ul class="simple">
<li><cite>RemoteReference &lt;twisted.spread.pb.RemoteReference&gt;</cite>
: <tt class="docutils literal">spread/pb.py</tt></li>
<li><cite>pb.Root &lt;twisted.spread.pb.Root&gt;</cite>
: <tt class="docutils literal">spread/pb.py</tt> , actually defined as
<tt class="docutils literal">twisted.spread.flavors.Root</tt>
in <tt class="docutils literal">spread/flavors.py</tt></li>
<li><cite>pb.Referenceable &lt;twisted.spread.pb.Referenceable&gt;</cite>
: <tt class="docutils literal">spread/pb.py</tt> , actually defined as
<tt class="docutils literal">twisted.spread.flavors.Referenceable</tt>
in <tt class="docutils literal">spread/flavors.py</tt></li>
</ul>
<p>Classes and interfaces that get involved when you start to care
about authorization and security:</p>
<ul class="simple">
<li><cite>Portal &lt;twisted.cred.portal.Portal&gt;</cite>
: <tt class="docutils literal">cred/portal.py</tt></li>
<li><cite>IRealm &lt;twisted.cred.portal.IRealm&gt;</cite>
: <tt class="docutils literal">cred/portal.py</tt></li>
<li><cite>IPerspective &lt;twisted.spread.pb.IPerspective&gt;</cite>
: <tt class="docutils literal">spread/pb.py</tt> , which you will usually be interacting
with via <cite>pb.Avatar &lt;twisted.spread.pb.Avatar&gt;</cite> (a basic implementor of the interface).</li>
</ul>
<div class="section" id="subclassing-and-implementing">
<h3><a class="toc-backref" href="#id5">Subclassing and Implementing</a></h3>
<p>Technically you can subclass anything you want, but technically you
could also write a whole new framework, which would just waste a lot
of time. Knowing which classes are useful to subclass or which
interfaces to implement is one of the bits of knowledge that's crucial
to using PB (and all of Twisted) successfully. Here are some hints to
get started:</p>
<ul class="simple">
<li><cite>pb.Root &lt;twisted.spread.pb.Root&gt;</cite> , <cite>pb.Referenceable &lt;twisted.spread.pb.Referenceable&gt;</cite> : you'll
subclass these to make remotely-referenceable objects (i.e., objects
which you can call methods on remotely) using PB. You don't need to
change any of the existing behavior, just inherit all of it and add
the remotely-accessible methods that you want to export.</li>
<li><cite>pb.Avatar &lt;twisted.spread.pb.Avatar&gt;</cite> : You'll
be subclassing this when you get into PB programming with
authorization. This is an implementor of IPerspective.</li>
<li><cite>ICredentialsChecker &lt;twisted.cred.checkers.ICredentialsChecker&gt;</cite> : Implement this if
you want to authenticate your users against some sort of data store:
i.e., an LDAP database, an RDBMS, etc. There are already a few
implementations of this for various back-ends in
twisted.cred.checkers.</li>
</ul>
<!-- <p>XXX: add lists of useful-to-override methods here</p> -->
</div>
</div>
<div class="section" id="things-you-can-call-remotely">
<h2><a class="toc-backref" href="#id6">Things you can Call Remotely</a></h2>
<p>At this writing, there are three "flavors" of objects that can
be accessed remotely through <cite>RemoteReference &lt;twisted.spread.pb.RemoteReference&gt;</cite> objects. Each of these
flavors has a rule for how the <tt class="docutils literal">callRemote</tt>
message is transformed into a local method call on the server.  In
order to use one of these "flavors" , subclass them and name your
published methods with the appropriate prefix.</p>
<ul>
<li><p class="first"><cite>twisted.spread.pb.IPerspective</cite> implementors</p>
<p>This is the first interface we deal with. It is a "perspective"
onto your PB application.  Perspectives are slightly special because
they are usually the first object that a given user can access in
your application (after they log on).  A user should only receive a
reference to their <em>own</em> perspective. PB works hard to
verify, as best it can, that any method that can be called on a
perspective directly is being called on behalf of the user who is
represented by that perspective.  (Services with unusual
requirements for "on behalf of" , such as simulations with the
ability to posses another player's avatar, are accomplished by
providing indirected access to another user's perspective.)</p>
<p>Perspectives are not usually serialized as remote references, so
do not return an IPerspective-implementor directly.</p>
<p>The way most people will want to implement IPerspective is by
subclassing pb.Avatar. Remotely accessible methods on pb.Avatar
instances are named with the <tt class="docutils literal">perspective_</tt> prefix.</p>
</li>
<li><p class="first"><cite>twisted.spread.pb.Referenceable</cite></p>
<p>Referenceable objects are the simplest kind of PB object.  You can call
methods on them and return them from methods to provide access to other
objects' methods.</p>
<p>However, when a method is called on a Referenceable, it's not possible to
tell who called it.</p>
<p>Remotely accessible methods on Referenceables are named with the
<tt class="docutils literal">remote_</tt> prefix.</p>
</li>
<li><p class="first"><cite>twisted.spread.pb.Viewable</cite></p>
<p>Viewable objects are remotely referenceable objects which have the
additional requirement that it must be possible to tell who is calling them.
The argument list to a Viewable's remote methods is modified in order to
include the Perspective representing the calling user.</p>
<p>Remotely accessible methods on Viewables are named with the
<tt class="docutils literal">view_</tt> prefix.</p>
</li>
</ul>
</div>
<div class="section" id="things-you-can-copy-remotely">
<h2><a class="toc-backref" href="#id7">Things you can Copy Remotely</a></h2>
<p>In addition to returning objects that you can call remote methods on, you
can return structured copies of local objects.</p>
<p>There are 2 basic flavors that allow for copying objects remotely.  Again,
you can use these by subclassing them.  In order to specify what state you want
to have copied when these are serialized, you can either use the Python default
<tt class="docutils literal">__getstate__</tt> or specialized method calls for that
flavor.</p>
<ul>
<li><p class="first"><cite>twisted.spread.pb.Copyable</cite></p>
<p>This is the simpler kind of object that can be copied.  Every time this
object is returned from a method or passed as an argument, it is serialized
and unserialized.</p>
<p><cite>Copyable &lt;twisted.spread.pb.Copyable&gt;</cite>
provides a method you can override, <tt class="docutils literal">getStateToCopyFor(perspective)</tt> , which
allows you to decide what an object will look like for the
perspective who is requesting it. The <tt class="docutils literal">perspective</tt> argument will be the perspective
which is either passing an argument or returning a result an
instance of your Copyable class.</p>
<p>For security reasons, in order to allow a particular Copyable class to
actually be copied, you must declare a <tt class="docutils literal">RemoteCopy</tt>
handler for
that Copyable subclass.  The easiest way to do this is to declare both in the
same module, like so:</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">twisted.spread</span> <span class="kn">import</span> <span class="n">flavors</span>
<span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="n">flavors</span><span class="o">.</span><span class="n">Copyable</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="k">class</span> <span class="nc">RemoteFoo</span><span class="p">(</span><span class="n">flavors</span><span class="o">.</span><span class="n">RemoteCopy</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="n">flavors</span><span class="o">.</span><span class="n">setUnjellyableForClass</span><span class="p">(</span><span class="n">Foo</span><span class="p">,</span> <span class="n">RemoteFoo</span><span class="p">)</span>
</pre></div>
<p>In this case, each time a Foo is copied between peers, a RemoteFoo will be
instantiated and populated with the Foo's state.  If you do not do this, PB
will complain that there have been security violations, and it may close the
connection.</p>
</li>
<li><p class="first"><cite>twisted.spread.pb.Cacheable</cite></p>
<p>Let me preface this with a warning: Cacheable may be hard to understand.
The motivation for it may be unclear if you don't have some experience with
real-world applications that use remote method calling of some kind.  Once
you understand why you need it, what it does will likely seem simple and
obvious, but if you get confused by this, forget about it and come back
later.  It's possible to use PB without understanding Cacheable at all.</p>
<p>Cacheable is a flavor which is designed to be copied only when necessary,
and updated on the fly as changes are made to it.  When passed as an argument
or a return value, if a Cacheable exists on the side of the connection it is
being copied to, it will be referred to by ID and not copied.</p>
<p>Cacheable is designed to minimize errors involved in replicating an object
between multiple servers, especially those related to having stale
information.  In order to do this, Cacheable automatically registers
observers and queries state atomically, together.  You can override the
method <tt class="docutils literal">getStateToCacheAndObserveFor(self, perspective, observer)</tt> in order to specify how your observers will be
stored and updated.</p>
<p>Similar to
<tt class="docutils literal">getStateToCopyFor</tt> ,
<tt class="docutils literal">getStateToCacheAndObserveFor</tt> gets passed a
perspective.  It also gets passed an
<tt class="docutils literal">observer</tt> , which is a remote reference to a
"secret" fourth referenceable flavor:
<cite>RemoteCache &lt;twisted.spread.pb.RemoteCache&gt;</cite> .</p>
<p>A <cite>RemoteCache &lt;twisted.spread.pb.RemoteCache&gt;</cite> is simply
the object that represents your
<cite>Cacheable &lt;twisted.spread.pb.Cacheable&gt;</cite> on the other side
of the connection.  It is registered using the same method as
<cite>RemoteCopy &lt;twisted.spread.pb.RemoteCopy&gt;</cite> , above.
RemoteCache is different, however, in that it will be referenced by its peer.
It acts as a Referenceable, where all methods prefixed with
<tt class="docutils literal">observe_</tt> will be callable remotely.  It is
recommended that your object maintain a list (note: library support for this
is forthcoming!) of observers, and update them using
<tt class="docutils literal">callRemote</tt> when the Cacheable changes in a way
that should be noticeable to its clients.</p>
<p>Finally, when all references to a
<cite>Cacheable &lt;twisted.spread.pb.Cacheable&gt;</cite> from a given
perspective are lost,
<tt class="docutils literal">stoppedObserving(perspective, observer)</tt>
will be called on the
<cite>Cacheable &lt;twisted.spread.pb.Cacheable&gt;</cite> , with the same
perspective/observer pair that <tt class="docutils literal">getStateToCacheAndObserveFor</tt> was
originally called with.  Any cleanup remote calls can be made there, as well
as removing the observer object from any lists which it was previously in.
Any further calls to this observer object will be invalid.</p>
</li>
</ul>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Most of Twisted is like this.  Hell, most of
Unix is like this: if <em>you</em>  think it would be useful, someone else has
probably thought that way in the past, and acted on it, and you can take
advantage of the tool they created to solve the same problem you're facing
now.</td></tr>
</tbody>
</table>

</div>

        </div>
        </div>
        </div>
<div class="sphinxsidebar">
<div class="sphinxsidebarwrapper">
<div class="toc" id="">
<p class="topic-title">Table Of Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id3">Introduction</a></li>
<li><a class="reference internal" href="#object-roadmap" id="id4">Object Roadmap</a><ul>
<li><a class="reference internal" href="#subclassing-and-implementing" id="id5">Subclassing and Implementing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#things-you-can-call-remotely" id="id6">Things you can Call Remotely</a></li>
<li><a class="reference internal" href="#things-you-can-copy-remotely" id="id7">Things you can Copy Remotely</a></li>
</ul>
</div>
</div>
</div>    </div>

    </section>

        <div id="footer"><hr>
                <div> </div>
                <p class="left2">
        Copyright 2021, Twisted Matrix Labs. Ver 21.2.0. Built on 2021-02-28.<br />
        Site design<br />
        By <a href="http://huw.ugbox.net/">huw.wilkins.</a>

                </p>
                <p class="right"></p>
        </div>


</body>
</html>